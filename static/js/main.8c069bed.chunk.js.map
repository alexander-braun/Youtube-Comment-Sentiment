{"version":3,"sources":["actions/setKeycounts.js","actions/constants.js","actions/setVideoTitle.js","actions/setComments.js","actions/setSentiments.js","components/Search.js","actions/setSingleWordSentiments.js","actions/setHighestAndLowestCommentCount.js","components/Resizeobserver.js","components/Bubblechart.js","actions/setChoice.js","components/MaxComments.js","components/InfiniteScrollWindow.js","components/Display.js","App.js","reducers/sentiment.js","reducers/singleWordSentiments.js","reducers/index.js","reducers/videoTitle.js","reducers/keyCounts.js","reducers/comments.js","reducers/highestAndLowestCommentCount.js","reducers/choice.js","store/index.js","index.js"],"names":["setKeycounts","keyCounts","type","setVideoTitle","videoTitle","setComments","comments","setCommentCount","commentCount","Analyzer","require","SentimentAnalyzer","stemmer","PorterStemmer","keyword_extractor","apiKey","process","useStyles","makeStyles","theme","searchIcon","color","position","right","cursor","fontSize","getKeywords","keywords","i","length","extraction","extract","language","remove_digits","return_changed_case","remove_duplicates","push","countKeywords","uniqueKeywords","keyword","word","toLowerCase","indexOf","keyCount","findLikesForHighestAndLowestComment","highest","lowest","highestCommentLikes","lowestCommentLikes","comment","overallSentiment","analyzer","sentiments","parseFloat","sentimentCount","lowWords","highWords","tokenized","split","sentiSingle","j","obj","getSentiment","sentiment","isNaN","cleanComments","cleanedComments","getVideoTitle","ID","a","undefined","url","fetch","response","json","data","title","Search","useState","videoLink","updateVideoLink","videoID","updateVideoID","dispatch","useDispatch","useEffect","link","equalSignIndex","search","slice","shortenToVideoID","calc","e","preventDefault","getComments","flat","sentimentCollector","highestComment","lowestComment","lowestSingleWords","highestSingleWords","highestLowest","highLowCommentCount","fetchComments","textArr","token","maxResults","nextPageToken","map","splitcomment","classes","className","placeholder","id","name","onChange","target","value","onClick","useResizeObserver","ref","dimensions","setDimensions","observeTarget","current","resizeObserver","ResizeObserver","entries","forEach","entry","contentRect","observe","unobserve","Bubblechart","dataSingleWords","svgRef","useRef","wrapperRef","Object","scoreValues","newEntries","Number","sort","b","scoreCount","window","innerWidth","filter","arr","heighestXEntries","cleanEntries","amount","sentimentWordsCombined","category","keys","bubbles2Count","width","count","key","minValue","maxValue","choice","updateChoice","dataChoice","useCallback","minMaxNumbers","d3","svg","select","mouseEnter","selectAll","join","enter","append","attr","node","element","height","style","colorScale","colorScaleS","text","x","scaleOrdinal","domain","Set","range","scaleLinear","scaleBubbles","scaleL","scaleLS","xCenter","forceSimulation","force","forceManyBody","strength","d","forceCenter","forceCollide","radius","Math","abs","on","y","remove","handleChange","setChoice","document","getElementById","classList","add","Comments","styleHighest","styleLowest","average","useSelector","state","highestAndLowestCommentCount","output","heading","uuidv4","toString","reduce","generateSentimentField","indicator","sorted","values","index","reverse","usedIndexes","InfiniteScrollWindow","commentsFiltered","setCommentsFiltered","positiveComments","setPositiveComments","negativeComments","setNegativeComments","positive","negative","filterComments","hasmoreItems","setHasmoreItems","pageStart","loadMore","hasMore","loader","useWindow","getScrollParent","getElementsByClassName","Display","singleWordSentiments","MaxComments","App","initialState","combineReducers","action","middleware","thunk","store","createStore","rootReducer","composeWithDevTools","applyMiddleware","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.8c069bed.chunk.js","sourcesContent":["import { SET_KEYCOUNTS } from './constants';\r\n\r\nexport const setKeycounts = (keyCounts) => ({\r\n  type: SET_KEYCOUNTS,\r\n  keyCounts,\r\n});\r\n","export const SET_VIDEO_TITLE = 'SET_VIDEO_TITLE';\nexport const SET_SENTIMENT = 'SET_SENTIMENT';\nexport const SET_SENTIMENT_COUNT = 'SET_SENTIMENT_COUNT';\nexport const SET_HIGHEST_COMMENT = 'SET_HIGHEST_COMMENT';\nexport const SET_LOWEST_COMMENT = 'SET_LOWEST_COMMENT';\nexport const SET_KEYCOUNTS = 'SET_KEYCOUNTS';\nexport const SET_COMMENT_COUNT = 'SET_COMMENT_COUNT';\nexport const SET_COMMENTS = 'SET_COMMENTS';\nexport const SET_HIGHEST_AND_LOWEST_COMMENT_COUNT =\n  'SET_HIGHEST_AND_LOWEST_COMMENT_COUNT';\nexport const SET_HIGHEST_SENTIMENT_SINGLE_WORDS =\n  'SET_HIGHEST_SENTIMENT_SINGLE_WORD';\nexport const SET_LOWEST_SENTIMENT_SINGLE_WORDS =\n  'SET_LOWEST_SENTIMENT_SINGLE_WORD';\nexport const SET_CHOICE = 'SET_CHOICE';\n","import { SET_VIDEO_TITLE } from './constants';\r\n\r\nexport const setVideoTitle = (videoTitle) => ({\r\n  type: SET_VIDEO_TITLE,\r\n  videoTitle,\r\n});\r\n","import { SET_COMMENTS } from './constants';\r\n\r\nexport const setComments = (comments) => ({\r\n  type: SET_COMMENTS,\r\n  comments,\r\n});\r\n","import {\r\n  SET_SENTIMENT,\r\n  SET_SENTIMENT_COUNT,\r\n  SET_HIGHEST_COMMENT,\r\n  SET_LOWEST_COMMENT,\r\n  SET_COMMENT_COUNT,\r\n} from './constants';\r\n\r\nexport const setSentiment = (sentiment) => ({\r\n  type: SET_SENTIMENT,\r\n  sentiment,\r\n});\r\n\r\nexport const setSentimentCount = (sentimentCount) => ({\r\n  type: SET_SENTIMENT_COUNT,\r\n  sentimentCount,\r\n});\r\n\r\nexport const setHighestComment = (highestComment) => ({\r\n  type: SET_HIGHEST_COMMENT,\r\n  highestComment,\r\n});\r\n\r\nexport const setLowestComment = (lowestComment) => ({\r\n  type: SET_LOWEST_COMMENT,\r\n  lowestComment,\r\n});\r\n\r\nexport const setCommentCount = (commentCount) => ({\r\n  type: SET_COMMENT_COUNT,\r\n  commentCount,\r\n});\r\n","import React, { useState, useEffect } from 'react';\r\nimport { useDispatch } from 'react-redux';\r\nimport SearchIcon from '@material-ui/icons/Search';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\nimport { setKeycounts } from '../actions/setKeycounts';\r\nimport { setVideoTitle } from '../actions/setVideoTitle';\r\nimport { setComments } from '../actions/setComments';\r\nimport { setHighestAndLowestCommentCount } from '../actions/setHighestAndLowestCommentCount';\r\nimport {\r\n  setHighestSingleWords,\r\n  setLowestSingleWords,\r\n} from '../actions/setSingleWordSentiments';\r\nimport {\r\n  setSentiment,\r\n  setSentimentCount,\r\n  setHighestComment,\r\n  setLowestComment,\r\n  setCommentCount,\r\n} from '../actions/setSentiments';\r\n\r\nvar Analyzer = require('natural').SentimentAnalyzer;\r\nvar stemmer = require('natural').PorterStemmer;\r\nvar keyword_extractor = require('keyword-extractor');\r\nlet apiKey = process.env.REACT_APP_API_KEY;\r\n\r\nconst useStyles = makeStyles((theme) => ({\r\n  searchIcon: {\r\n    color: 'rgba(128, 128, 128, 0.5)',\r\n    position: 'absolute',\r\n    right: '10px',\r\n    cursor: 'pointer',\r\n    fontSize: '2.25rem',\r\n  },\r\n}));\r\n\r\n/**\r\n * Gets english lang keywords with the help of keywordextractor from all the comments for the bubblechart\r\n */\r\nconst getKeywords = (comments) => {\r\n  let keywords = [];\r\n\r\n  for (let i = 0; i < comments.length; i++) {\r\n    let extraction = keyword_extractor.extract(comments[i], {\r\n      language: 'english',\r\n      remove_digits: true,\r\n      return_changed_case: true,\r\n      remove_duplicates: false,\r\n    });\r\n    keywords.push(extraction);\r\n  }\r\n  return keywords;\r\n};\r\n\r\n/**\r\n * Counts Keywords for the bubblechart comparsion\r\n */\r\nconst countKeywords = (keywords) => {\r\n  // Get all the unique keywords\r\n  let uniqueKeywords = [];\r\n  for (let i = 0; i < keywords.length; i++) {\r\n    for (let keyword of keywords[i]) {\r\n      if (keyword) {\r\n        let word = keyword.toLowerCase();\r\n        uniqueKeywords.indexOf(word) === -1 && uniqueKeywords.push(word);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Put all of them into an object an count them\r\n  let keyCount = {};\r\n  for (let i = 0; i < keywords.length; i++) {\r\n    for (let keyword of keywords[i]) {\r\n      keyCount[keyword] && keyCount[keyword]++;\r\n      !keyCount[keyword] && (keyCount[keyword] = 1);\r\n    }\r\n  }\r\n\r\n  return keyCount;\r\n};\r\n\r\n/**\r\n * Takes the highest and lowest comments and gets the like count\r\n */\r\nconst findLikesForHighestAndLowestComment = (highest, lowest, comments) => {\r\n  let highestCommentLikes = 0;\r\n  let lowestCommentLikes = 0;\r\n  for (let comment of comments) {\r\n    if (comment[0] === highest[1]) {\r\n      highestCommentLikes = comment[1];\r\n    }\r\n    if (comment[0] === lowest[1]) {\r\n      lowestCommentLikes = comment[1];\r\n    }\r\n  }\r\n  return [highestCommentLikes, lowestCommentLikes];\r\n};\r\n\r\n/**\r\n * Goes through all the comments and finds words <= -1 or >= 1 and puts them in an array\r\n * Counts positive, neutral and negative comments\r\n * Finds the highest and lowest sentiment comments\r\n * Gets the overall sentiment\r\n */\r\nconst overallSentiment = (comments) => {\r\n  let analyzer = new Analyzer('English', stemmer, 'afinn');\r\n  let length = comments.length;\r\n  let sentiments = parseFloat(0);\r\n\r\n  // Counts POS and NEG comments [POS,NEUTRAL,NEG]\r\n  let sentimentCount = [0, 0, 0];\r\n\r\n  // Set highest and lowest commentscore\r\n  let highest = [-10, null];\r\n  let lowest = [10, null];\r\n\r\n  // Array of objects collecting words <= -1 or >= 1\r\n  let lowWords = [];\r\n  let highWords = [];\r\n\r\n  for (let i = 0; i < length; i++) {\r\n    // Split comment to words\r\n    let tokenized = comments[i].split(' ');\r\n\r\n    // Get the single word sentiments\r\n    let sentiSingle;\r\n    for (let j = 0; j < tokenized.length; j++) {\r\n      sentiSingle = parseFloat(analyzer.getSentiment([tokenized[j]]));\r\n      let obj = {};\r\n      if (sentiSingle <= -1) {\r\n        obj['word'] = tokenized[j];\r\n        obj['sentiment'] = sentiSingle;\r\n        lowWords.push(obj);\r\n      } else if (sentiSingle >= 1) {\r\n        obj['word'] = tokenized[j];\r\n        obj['sentiment'] = sentiSingle;\r\n        highWords.push(obj);\r\n      }\r\n    }\r\n\r\n    // Get the whole comments sentiment from here on\r\n    const sentiment = parseFloat(analyzer.getSentiment(tokenized));\r\n\r\n    // Add POS or NEG or NEUTRAL\r\n    sentiment > 0 && sentimentCount[2]++;\r\n    sentiment === 0 && sentimentCount[1]++;\r\n    sentiment < 0 && sentimentCount[0]++;\r\n\r\n    sentiment > highest[0] &&\r\n      (highest[0] = sentiment) &&\r\n      (highest[1] = comments[i]);\r\n    sentiment < lowest[0] &&\r\n      (lowest[0] = sentiment) &&\r\n      (lowest[1] = comments[i]);\r\n\r\n    // Sometimes NaN is returned so this prevents it from beeing added to the overall score\r\n    if (!isNaN(sentiment)) {\r\n      sentiments += sentiment;\r\n    }\r\n  }\r\n  return [\r\n    sentiments / length,\r\n    sentimentCount,\r\n    highest,\r\n    lowest,\r\n    lowWords,\r\n    highWords,\r\n  ];\r\n};\r\n\r\n/**\r\n * Takes the video link and returns the ID\r\n */\r\nconst shortenToVideoID = (link) => {\r\n  const equalSignIndex = link.search('=');\r\n  const videoID = link.slice(equalSignIndex + 1);\r\n  return videoID;\r\n};\r\n\r\n/**\r\n * Seperates the pure text from additional information wich are not needed in this step\r\n */\r\nconst cleanComments = (comments) => {\r\n  let cleanedComments = [];\r\n  for (let i = 0; i < comments.length; i++) {\r\n    cleanedComments.push(comments[i][0]);\r\n  }\r\n  return cleanedComments;\r\n};\r\n\r\n/**\r\n * Uses the noembed site to get the video title, reduces api cost\r\n */\r\nconst getVideoTitle = async (ID) => {\r\n  if (ID && ID !== undefined) {\r\n    let url = `https://noembed.com/embed?url=https%3A%2F%2Fhttps://www.youtube.com/watch?v=${ID}`;\r\n    const response = await fetch(url);\r\n    const data = await response.json();\r\n    const title = await data['title'];\r\n    return title;\r\n  }\r\n  return null;\r\n};\r\n\r\nfunction Search() {\r\n  const [videoLink, updateVideoLink] = useState('');\r\n  const [videoID, updateVideoID] = useState();\r\n  const dispatch = useDispatch();\r\n\r\n  useEffect(() => {\r\n    // Get and Update Video ID\r\n    const ID = shortenToVideoID(videoLink);\r\n    updateVideoID(ID);\r\n  }, [videoLink]);\r\n\r\n  // Main knot to get all needed information from the api\r\n  const calc = async (e) => {\r\n    e.preventDefault();\r\n\r\n    // Get and set Video Title\r\n    let videoTitle = await getVideoTitle(videoID);\r\n    dispatch(setVideoTitle(videoTitle));\r\n\r\n    // Get last 100 comments (YT always returns 100 if there are at least 100 comments)\r\n    let comments = await getComments();\r\n    if (comments.length === 0) return;\r\n    comments = comments.flat();\r\n    dispatch(setComments(comments));\r\n\r\n    // Extract pure comments from [comment, likes, id]\r\n    let cleanedComments = cleanComments(comments);\r\n    let commentCount = cleanedComments.length;\r\n    dispatch(setCommentCount(commentCount));\r\n\r\n    // Calculate the sentiment and update\r\n    let sentimentCollector = overallSentiment(cleanedComments);\r\n    dispatch(setSentiment(sentimentCollector[0]));\r\n    dispatch(setSentimentCount(sentimentCollector[1]));\r\n    dispatch(setHighestComment(sentimentCollector[2]));\r\n    dispatch(setLowestComment(sentimentCollector[3]));\r\n    dispatch(setLowestSingleWords(sentimentCollector[4]));\r\n    dispatch(setHighestSingleWords(sentimentCollector[5]));\r\n\r\n    // Get and set the likes for the highest and lowest sentiment comments\r\n    let highestLowest = findLikesForHighestAndLowestComment(\r\n      sentimentCollector[2],\r\n      sentimentCollector[3],\r\n      comments\r\n    );\r\n    dispatch(setHighestAndLowestCommentCount(highestLowest));\r\n\r\n    // Get all the keywords from all the comments and count them\r\n    let keywords = getKeywords(cleanedComments);\r\n    let keyCounts = countKeywords(keywords);\r\n    dispatch(setKeycounts(keyCounts));\r\n  };\r\n\r\n  // Connection to the youtube API -> setup to get more then 100 comments (all the comments f.e.) but too much api cost atm\r\n  const getComments = () => {\r\n    let ID = videoID;\r\n    let maxResults = 100;\r\n    let analyzer = new Analyzer('English', stemmer, 'afinn');\r\n\r\n    // Recursive Function to get each 100 comments\r\n    async function fetchComments(textArr = [], token) {\r\n      // If there are X comments already in array return array\r\n      if (textArr[0] !== undefined) {\r\n        // Every array has 100 comments in it so maxResults / 100 >= textArr.length tests if the maxResult-propertie is fullfilled\r\n        if (maxResults / 100 >= textArr.length) {\r\n          return textArr;\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Change the url based on the existence of a nextpagetoken\r\n       * Setup and working for future use but API cost was too high\r\n       */\r\n      let url;\r\n      if (token) {\r\n        url = `https://www.googleapis.com/youtube/v3/commentThreads?key=${apiKey}&textFormat=plainText&part=snippet&videoId=${ID}&maxResults=${maxResults}&pageToken=${token}`;\r\n      } else {\r\n        url = `https://www.googleapis.com/youtube/v3/commentThreads?key=${apiKey}&textFormat=plainText&part=snippet&videoId=${ID}&maxResults=${maxResults}`;\r\n      }\r\n\r\n      // Grab the data and get comment and likecount for comment\r\n      const response = await fetch(url);\r\n      const data = await response.json();\r\n      const nextPageToken = await data['nextPageToken'];\r\n      let comments = await data['items'];\r\n\r\n      // If the address was f.e. empty and there are no results just return []\r\n      if (!comments) return [];\r\n\r\n      // Else put the comments and the likecount (not used yet) into an array\r\n      comments = comments.map((comment) => {\r\n        const splitcomment = comment['snippet']['topLevelComment']['snippet'][\r\n          'textDisplay'\r\n        ].split(' ');\r\n        return [\r\n          comment['snippet']['topLevelComment']['snippet']['textDisplay'],\r\n          comment['snippet']['topLevelComment']['snippet']['likeCount'],\r\n          comment['snippet']['topLevelComment']['snippet']['authorChannelId'][\r\n            'value'\r\n          ],\r\n          analyzer.getSentiment(splitcomment),\r\n          comment['snippet']['topLevelComment']['snippet']['authorChannelUrl'],\r\n        ];\r\n      });\r\n\r\n      // Push data to array that is passed along\r\n      textArr.push(comments);\r\n\r\n      /**\r\n       * If there is one more comment page to load grab the nextpagetoken for that site\r\n       * Not used as it eats the free api usage too quickly. Could grab all other comments\r\n       * If used\r\n       */\r\n      if (nextPageToken) {\r\n        return fetchComments(textArr, nextPageToken);\r\n      }\r\n\r\n      // Or else just return the array\r\n      else if (!nextPageToken) return textArr;\r\n    }\r\n\r\n    return fetchComments([], null);\r\n  };\r\n\r\n  const classes = useStyles();\r\n\r\n  return (\r\n    <div className=\"search\">\r\n      <form className=\"search__form\">\r\n        <input\r\n          placeholder=\"Enter Youtube Video Link...\"\r\n          type=\"text\"\r\n          id=\"video-link\"\r\n          name=\"video-link\"\r\n          onChange={(e) => updateVideoLink(e.target.value)}\r\n          value={videoLink}\r\n          className=\"search__link-input\"\r\n        />\r\n        <SearchIcon className={classes.searchIcon} onClick={calc} />\r\n      </form>\r\n      <button onClick={calc} value=\"Search\" className=\"search__button\">\r\n        Search\r\n      </button>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Search;\r\n","import {\r\n  SET_HIGHEST_SENTIMENT_SINGLE_WORDS,\r\n  SET_LOWEST_SENTIMENT_SINGLE_WORDS,\r\n} from './constants';\r\n\r\nexport const setHighestSingleWords = (highestSingleWords) => ({\r\n  type: SET_HIGHEST_SENTIMENT_SINGLE_WORDS,\r\n  highestSingleWords,\r\n});\r\n\r\nexport const setLowestSingleWords = (lowestSingleWords) => ({\r\n  type: SET_LOWEST_SENTIMENT_SINGLE_WORDS,\r\n  lowestSingleWords,\r\n});\r\n","import { SET_HIGHEST_AND_LOWEST_COMMENT_COUNT } from './constants';\r\n\r\nexport const setHighestAndLowestCommentCount = (highLowCommentCount) => ({\r\n  type: SET_HIGHEST_AND_LOWEST_COMMENT_COUNT,\r\n  highLowCommentCount,\r\n});\r\n","import ResizeObserver from 'resize-observer-polyfill';\r\nimport { useEffect, useState } from 'react';\r\n\r\nconst useResizeObserver = (ref) => {\r\n  const [dimensions, setDimensions] = useState(null);\r\n  useEffect(() => {\r\n    const observeTarget = ref.current;\r\n    const resizeObserver = new ResizeObserver((entries) => {\r\n      entries.forEach((entry) => {\r\n        setDimensions(entry.contentRect);\r\n      });\r\n    });\r\n    resizeObserver.observe(observeTarget);\r\n    return () => {\r\n      resizeObserver.unobserve(observeTarget);\r\n    };\r\n  }, [ref]);\r\n  return dimensions;\r\n};\r\n\r\nexport default useResizeObserver;\r\n","import * as d3 from 'd3';\r\nimport {\r\n  select,\r\n  forceSimulation,\r\n  scaleOrdinal,\r\n  forceCollide,\r\n  forceManyBody,\r\n  forceCenter,\r\n  scaleLinear,\r\n} from 'd3';\r\nimport React, { useRef, useEffect, useState, useCallback } from 'react';\r\nimport useResizeObserver from './Resizeobserver';\r\nimport { useDispatch } from 'react-redux';\r\nimport { setChoice } from '../actions/setChoice';\r\n\r\nfunction Bubblechart({ data, dataSingleWords }) {\r\n  const svgRef = useRef();\r\n  const wrapperRef = useRef();\r\n  const dimensions = useResizeObserver(wrapperRef);\r\n  const entries = Object.entries(data);\r\n  const alphabet = 'abcdefghijklmnopqrstuvwxyz1234567890';\r\n  const dispatch = useDispatch();\r\n\r\n  let scoreValues = [];\r\n  const heighestXEntries = () => {\r\n    // Get all unique counts for a word and sort them\r\n    for (let entry of entries) {\r\n      if (scoreValues.indexOf(entry[1]) === -1)\r\n        scoreValues.push(Number(entry[1]));\r\n    }\r\n    scoreValues.sort((a, b) => a - b);\r\n\r\n    // ScoreCount is the max number of bubbles for the bubblediagram\r\n    let scoreCount = 25;\r\n    if (window.innerWidth < 700) scoreCount = 15;\r\n\r\n    // goes backwards through the scores and pushes [word, count] into newEntries\r\n    let newEntries = [];\r\n    for (let i = scoreValues.length; i > 0; i--) {\r\n      newEntries.push(\r\n        ...entries.filter((arr) => {\r\n          return arr[1] === scoreValues[i] && arr;\r\n        })\r\n      );\r\n      if (newEntries.length >= scoreCount) break;\r\n    }\r\n    return newEntries.slice(0, scoreCount);\r\n  };\r\n\r\n  let newEntries = heighestXEntries();\r\n\r\n  // Sorts the entries as object (for d3) into an array. Gets rid of single character mentions like = or -\r\n  let cleanEntries = [];\r\n  for (let entry of newEntries) {\r\n    if (entry[1] > 1) {\r\n      if (alphabet.indexOf(entry[0][0]) === -1) {\r\n        continue;\r\n      }\r\n      let obj = { word: null, amount: null };\r\n      obj['word'] = entry[0];\r\n      obj['amount'] = entry[1];\r\n      cleanEntries.push(obj);\r\n    }\r\n  }\r\n\r\n  // Merge Singlewordsentiments and assign category 0 or 1\r\n  let sentimentWordsCombined = [];\r\n  let category = 0;\r\n  let keys = Object.keys(dataSingleWords);\r\n\r\n  let bubbles2Count = 15;\r\n  if (dimensions && dimensions.width <= 700) bubbles2Count = 10;\r\n\r\n  let count = 0;\r\n\r\n  for (let key of keys) {\r\n    for (let i = 0; i < dataSingleWords[key].length; i++) {\r\n      if (count < bubbles2Count) {\r\n        let obj = dataSingleWords[key][i];\r\n        obj['category'] = category;\r\n        sentimentWordsCombined.push(obj);\r\n        count++;\r\n      }\r\n    }\r\n    count = 0;\r\n    category++;\r\n  }\r\n\r\n  // Base bubbles on choice of keywords or sentiment words\r\n  const [choice, updateChoice] = useState('keywords');\r\n  const dataChoice = useCallback(() => {\r\n    return choice === 'keywords' ? cleanEntries : sentimentWordsCombined;\r\n  }, [choice, cleanEntries, sentimentWordsCombined]);\r\n\r\n  // Gets the minValue and maxValue of word counts\r\n  let minValue;\r\n  let maxValue;\r\n\r\n  if (dataChoice().length !== 0) {\r\n    let minMaxNumbers = [];\r\n    for (let entry of dataChoice()) {\r\n      minMaxNumbers.push(entry['amount' || 'sentiment']);\r\n    }\r\n    minValue = d3.min(minMaxNumbers);\r\n    maxValue = d3.max(minMaxNumbers);\r\n  }\r\n\r\n  useEffect(() => {\r\n    let data = dataChoice();\r\n    if (!dimensions) return;\r\n    let svg = null;\r\n    svg = select(svgRef.current);\r\n\r\n    const mouseEnter = (value) => {\r\n      svg\r\n        .selectAll('.rec')\r\n        .data(() => {\r\n          if (choice === 'sentiment') {\r\n            return [[value['sentiment'], value['word']]];\r\n          } else return [[value['amount'], value['word']]];\r\n        })\r\n        .join((enter) => enter.append('rect'))\r\n        .attr('class', 'rec')\r\n        .attr('x', (node) => {\r\n          for (let element of cleanEntries) {\r\n            if (choice !== 'sentiment') {\r\n              if (element['word'] === node[1]) {\r\n                if (dimensions.width <= 700) {\r\n                  return dimensions.width / 2 - 175;\r\n                } else return element['x'] + 100;\r\n              }\r\n            } else return dimensions.width / 2 - (node[1].length * 4 + 150);\r\n          }\r\n        })\r\n        .attr('width', (node) => {\r\n          return `${node[1].length * 4 + 300}px`;\r\n        })\r\n        .attr('height', '40px')\r\n        .attr('text-anchor', 'middle')\r\n        .attr('y', (node) => {\r\n          for (let element of cleanEntries) {\r\n            if (choice !== 'sentiment') {\r\n              if (element['word'] === node[1]) {\r\n                return element['y'];\r\n              }\r\n            } else return dimensions.height / 2;\r\n          }\r\n        })\r\n        .attr('opacity', 1)\r\n        .attr('fill', 'white')\r\n        .style('stroke', (node) => {\r\n          if (choice !== 'sentiment') {\r\n            return colorScale(node[0]);\r\n          } else {\r\n            return colorScaleS(node[0]);\r\n          }\r\n        })\r\n        .style('stroke-width', 2)\r\n        .attr('rx', 4);\r\n      svg\r\n        .selectAll('.tooltip')\r\n        .data(() => {\r\n          if (choice === 'sentiment') {\r\n            return [[value['sentiment'], value['word']]];\r\n          } else return [[value['amount'], value['word']]];\r\n        })\r\n        .join((enter) => enter.append('text'))\r\n        .attr('class', 'tooltip')\r\n        .text((node) => {\r\n          if (choice === 'sentiment') {\r\n            return `sentiment: ${node[0]}, word: \"${node[1]}\"`;\r\n          } else return `${node[0]} times used: \"${node[1]}\"`;\r\n        })\r\n        .attr('x', (node) => {\r\n          let x = dimensions.width / 2;\r\n          for (let element of cleanEntries) {\r\n            if (element['word'] === node[1]) {\r\n              if (choice !== 'sentiment') {\r\n                if (dimensions.width <= 700) {\r\n                  x = dimensions.width / 2;\r\n                } else x = element['x'] + node[1].length * 4 + 200;\r\n              } else x = dimensions.width / 2;\r\n            }\r\n          }\r\n          return x;\r\n        })\r\n        .attr('text-anchor', 'middle')\r\n        .attr('y', (node) => {\r\n          for (let element of cleanEntries) {\r\n            if (choice !== 'sentiment') {\r\n              if (element['word'] === node[1]) {\r\n                return element['y'] + 25;\r\n              }\r\n            } else return dimensions.height / 2 + 25;\r\n          }\r\n        })\r\n        .attr('opacity', 1)\r\n        .attr('fill', 'black');\r\n    };\r\n    // Colors for Bubbles\r\n    const colorScale = scaleOrdinal()\r\n      .domain(new Set(scoreValues))\r\n      .range([\r\n        '#00e8e8',\r\n        '#F2CB05',\r\n        '#F28705',\r\n        '#D92818',\r\n        '#D94141',\r\n        '#0ba3ff',\r\n        '#6aafda',\r\n      ]);\r\n\r\n    const colorScaleS = scaleLinear()\r\n      .domain([-2, 2])\r\n      .range(['rgb(217, 29, 0)', 'rgb(66, 230, 0)']);\r\n\r\n    // Determines the scale based on screen size\r\n    let scaleBubbles = 1.3;\r\n    if (dimensions.width <= 700) scaleBubbles = 0.8;\r\n\r\n    // Scale for bubbles using scale var\r\n    const scaleL = d3\r\n      .scaleSqrt()\r\n      .domain([minValue, maxValue])\r\n      .range([25 * scaleBubbles, 60 * scaleBubbles]);\r\n\r\n    let scaleBubblesS = 2;\r\n\r\n    const scaleLS = d3\r\n      .scaleSqrt()\r\n      .domain([0, 5])\r\n      .range([0 * scaleBubblesS, 25 * scaleBubblesS]);\r\n    svg.style('width', '100%').style('height', '100%');\r\n\r\n    svg.attr('viewbox', `0 0 ${dimensions.width} ${dimensions.height}`);\r\n\r\n    const xCenter = [\r\n      dimensions.width / 4,\r\n      dimensions.width - dimensions.width / 4,\r\n    ];\r\n\r\n    const simulationBubbles = () => {\r\n      forceSimulation(data)\r\n        .force('charge', forceManyBody().strength(20))\r\n        .force(\r\n          'x',\r\n          choice === 'sentiment'\r\n            ? d3.forceX().x((d) => {\r\n                if (choice === 'sentiment') {\r\n                  return d['category'] === 0 ? xCenter[0] : xCenter[1];\r\n                }\r\n              })\r\n            : null\r\n        )\r\n        .force(\r\n          'center',\r\n          forceCenter(dimensions.width / 2, dimensions.height / 2)\r\n        )\r\n        .force(\r\n          'collide',\r\n          forceCollide().radius((node) => {\r\n            if (choice === 'sentiment') {\r\n              return scaleLS(Math.abs(Number(node['sentiment'])));\r\n            } else return scaleL(node['amount']);\r\n          })\r\n        )\r\n        .on('tick', () => {\r\n          svg\r\n            .selectAll('.node')\r\n            .data(data)\r\n            .join('circle')\r\n            .attr('class', 'node')\r\n            .attr('r', (node) => {\r\n              if (choice === 'sentiment') {\r\n                return scaleLS(Math.abs(Number(node['sentiment'])));\r\n              } else return scaleL(node['amount']);\r\n            })\r\n            .style('fill', (node) => {\r\n              if (choice === 'sentiment') {\r\n                return colorScaleS(node['sentiment']);\r\n              } else return colorScale(node['amount']);\r\n            })\r\n            .attr('cx', (node) => node.x)\r\n            .attr('cy', (node) => node.y)\r\n            .on('mouseenter', (value) => {\r\n              mouseEnter(value);\r\n            })\r\n            .on('mouseleave', () => {\r\n              svg.selectAll('.tooltip').remove();\r\n              svg.selectAll('.rec').remove();\r\n            });\r\n          svg\r\n            .selectAll('.label')\r\n            .data(data)\r\n            .join('text')\r\n            .attr('class', 'label')\r\n            .attr('text-anchor', 'middle')\r\n            .attr('font-size', (node) => {\r\n              if (choice === 'sentiment') {\r\n                return scaleLS(Math.abs(node['sentiment'])) / 3;\r\n              } else return scaleL(node['amount']) / 3;\r\n            })\r\n            .attr('font-family', 'Open Sans')\r\n            .style('fill', 'black')\r\n            .attr('font-weight', '600')\r\n            .text((node) => {\r\n              return node['word'];\r\n            })\r\n            .attr('x', (node) => node.x)\r\n            .attr('y', (node) => node.y)\r\n            .on('mouseenter', (value) => {\r\n              mouseEnter(value);\r\n            });\r\n        });\r\n    };\r\n\r\n    simulationBubbles();\r\n  }, [\r\n    dimensions,\r\n    cleanEntries,\r\n    data,\r\n    maxValue,\r\n    minValue,\r\n    scoreValues,\r\n    dataChoice,\r\n    choice,\r\n    bubbles2Count,\r\n  ]);\r\n\r\n  const handleChange = (e) => {\r\n    e.preventDefault();\r\n    updateChoice(e.target.value);\r\n\r\n    dispatch(setChoice(e.target.value));\r\n\r\n    const id = e.target.id;\r\n    const el = document.getElementById(id);\r\n    el.classList.add('bubblechart__difficulty-select--selected');\r\n\r\n    if (id === 'compare-sentiment') {\r\n      document\r\n        .getElementById('keywords')\r\n        .classList.remove('bubblechart__difficulty-select--selected');\r\n    } else if (id === 'keywords') {\r\n      document\r\n        .getElementById('compare-sentiment')\r\n        .classList.remove('bubblechart__difficulty-select--selected');\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div ref={wrapperRef} className=\"bubblechart\">\r\n      <div className=\"bubblechart__select-menue\">\r\n        <button\r\n          className=\"bubblechart__difficulty-select bubblechart__difficulty-select--selected\"\r\n          value=\"keywords\"\r\n          id=\"keywords\"\r\n          onClick={(e) => handleChange(e)}\r\n        >\r\n          Keywords\r\n        </button>\r\n        <button\r\n          className=\"bubblechart__difficulty-select\"\r\n          value=\"sentiment\"\r\n          id=\"compare-sentiment\"\r\n          onClick={(e) => handleChange(e)}\r\n        >\r\n          Compare Sentiments\r\n        </button>\r\n      </div>\r\n      <svg ref={svgRef}></svg>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Bubblechart;\r\n","import { SET_CHOICE } from './constants';\r\n\r\nexport const setChoice = (choice) => ({\r\n  type: SET_CHOICE,\r\n  choice,\r\n});\r\n","import React from 'react';\r\nimport { scaleLinear } from 'd3';\r\nimport { useSelector } from 'react-redux';\r\nimport { v4 as uuidv4 } from 'uuid';\r\n\r\nfunction Comments({\r\n  lowestComment,\r\n  highestComment,\r\n  sentiment,\r\n  sentimentCount,\r\n}) {\r\n  const colorScale = scaleLinear()\r\n    .domain([-2, 2])\r\n    .range(['rgb(238, 0, 0)', 'rgb(66, 230, 0)']);\r\n\r\n  const styleHighest = {\r\n    color: colorScale(highestComment[0]),\r\n  };\r\n\r\n  const styleLowest = {\r\n    color: colorScale(lowestComment[0]),\r\n  };\r\n\r\n  const average = {\r\n    color: colorScale(sentiment),\r\n  };\r\n\r\n  const highestCommentLikes = useSelector(\r\n    (state) => state.highestAndLowestCommentCount[0]\r\n  );\r\n  const lowestCommentLikes = useSelector(\r\n    (state) => state.highestAndLowestCommentCount[1]\r\n  );\r\n\r\n  const generateSentimentField = () => {\r\n    const headings = [\r\n      'Highest Sentiment',\r\n      'Lowest Sentiment',\r\n      'Average Sentiment',\r\n    ];\r\n    let output = [];\r\n    for (let heading of headings) {\r\n      output.push(\r\n        <div className=\"card\" key={uuidv4()}>\r\n          <span className=\"card__heading\">\r\n            <h2 className=\"card__title\">{heading}</h2>\r\n            <div\r\n              className=\"card__sentiment\"\r\n              style={\r\n                heading === 'Lowest Sentiment'\r\n                  ? styleLowest\r\n                  : heading === 'Highest Sentiment'\r\n                  ? styleHighest\r\n                  : average\r\n              }\r\n            >\r\n              {heading === 'Highest Sentiment'\r\n                ? highestComment &&\r\n                  (highestComment[0] > 0 ? '+' : '') +\r\n                    highestComment[0].toString().slice(0, 5)\r\n                : heading === 'Lowest Sentiment'\r\n                ? lowestComment &&\r\n                  (lowestComment[0] > 0 ? '+' : '') +\r\n                    lowestComment[0].toString().slice(0, 5)\r\n                : (sentiment > 0 ? '+' : '') + sentiment.toString().slice(0, 4)}\r\n            </div>\r\n          </span>\r\n          {heading === 'Highest Sentiment' || heading === 'Lowest Sentiment' ? (\r\n            <div className=\"card__comment\">\r\n              {heading === 'Highest Sentiment'\r\n                ? `\"${highestComment[1]}\"`\r\n                : heading === 'Lowest Sentiment'\r\n                ? `\"${lowestComment[1]}\"`\r\n                : null}\r\n            </div>\r\n          ) : null}\r\n          {heading === 'Average Sentiment' ? (\r\n            <div className=\"card__average\">\r\n              <h6 className=\"card__average-sentiment\">\r\n                Negative Sentiments: {sentimentCount[0]}\r\n              </h6>\r\n              <h6 className=\"card__average-sentiment\">\r\n                Neutral Sentiments: {sentimentCount[1]}\r\n              </h6>\r\n              <h6 className=\"card__average-sentiment\">\r\n                Positive Sentiments: {sentimentCount[2]}\r\n              </h6>\r\n            </div>\r\n          ) : null}\r\n          {heading === 'Lowest Sentiment' ? (\r\n            <div className=\"card__comment-likes\">\r\n              Likes:\r\n              {lowestCommentLikes}\r\n            </div>\r\n          ) : heading === 'Highest Sentiment' ? (\r\n            <div className=\"card__comment-likes\">\r\n              Likes:\r\n              {highestCommentLikes}\r\n            </div>\r\n          ) : (\r\n            <div className=\"card__comment-likes\">\r\n              Comments: {sentimentCount.reduce((a, b) => a + b)}\r\n            </div>\r\n          )}\r\n        </div>\r\n      );\r\n    }\r\n    return output;\r\n  };\r\n\r\n  return <div className=\"comments\">{generateSentimentField()}</div>;\r\n}\r\n\r\nexport default Comments;\r\n","import React, { useState, useEffect } from 'react';\r\nimport { useSelector } from 'react-redux';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport InfiniteScroll from 'react-infinite-scroller';\r\n\r\n// Sort the comments by sentiment value\r\nconst sort = (comments, indicator) => {\r\n  let sorted = [];\r\n  let values = [];\r\n\r\n  // Give comments ID's for later identification\r\n  let index = 0;\r\n  for (let comment of comments) {\r\n    comment.push(index);\r\n    index++;\r\n  }\r\n\r\n  // Get all the sentiment-values\r\n  for (let comment of comments) {\r\n    values.push(comment[3]);\r\n  }\r\n\r\n  // Sort all the sentiment values\r\n  if (indicator === '+') {\r\n    values = values.sort((a, b) => a - b).reverse();\r\n  } else {\r\n    values = values.sort((a, b) => a - b);\r\n  }\r\n\r\n  /**\r\n   * Go through the values and find their belonging comment - if the\r\n   * index is already used, continue searching for the belonging value\r\n   */\r\n  const usedIndexes = [];\r\n  for (let value of values) {\r\n    for (let comment of comments) {\r\n      if (comment[3] === value && usedIndexes.indexOf(comment[5]) === -1) {\r\n        sorted.push(comment);\r\n        usedIndexes.push(comment[5]);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return sorted;\r\n};\r\n\r\n/**\r\n * Prefilter the comments into positive and negative comments\r\n * Makes the sorting easier later\r\n */\r\nconst filterComments = (comments) => {\r\n  let positive = [];\r\n  let negative = [];\r\n  for (let comment of comments) {\r\n    if (comment[3] > 0) {\r\n      positive.push(comment);\r\n    } else if (comment[3] < 0) {\r\n      negative.push(comment);\r\n    }\r\n  }\r\n\r\n  positive = sort(positive, '+');\r\n  negative = sort(negative, '-');\r\n\r\n  return [positive, negative];\r\n};\r\n\r\nfunction InfiniteScrollWindow() {\r\n  let comments = useSelector((state) => state.comments);\r\n  let [commentsFiltered, setCommentsFiltered] = useState();\r\n  let [positiveComments, setPositiveComments] = useState();\r\n  let [negativeComments, setNegativeComments] = useState();\r\n\r\n  useEffect(() => {\r\n    setCommentsFiltered(filterComments(comments));\r\n  }, [comments]);\r\n\r\n  useEffect(() => {\r\n    commentsFiltered && setPositiveComments(commentsFiltered[0].slice(0, 10));\r\n    commentsFiltered && setNegativeComments(commentsFiltered[1].slice(0, 10));\r\n  }, [commentsFiltered]);\r\n\r\n  const [hasmoreItems, setHasmoreItems] = useState(true);\r\n\r\n  const loadMorePositive = () => {\r\n    let count = positiveComments.length + 5;\r\n    if (count >= commentsFiltered[0].length) {\r\n      setHasmoreItems(false);\r\n      return;\r\n    }\r\n    setPositiveComments(commentsFiltered[0].slice(0, count));\r\n  };\r\n\r\n  const loadMoreNegative = () => {\r\n    let count = negativeComments.length + 5;\r\n    if (count >= commentsFiltered[1].length) {\r\n      setHasmoreItems(false);\r\n      return;\r\n    }\r\n    setNegativeComments(commentsFiltered[1].slice(0, count));\r\n  };\r\n\r\n  if (!positiveComments || !negativeComments) return null;\r\n\r\n  return (\r\n    <div className=\"infinite-wrapper\">\r\n      <div className=\"infinite-scroll\">\r\n        <h2 className=\"infinite-scroll__heading\">\r\n          Selected positive sentiments:\r\n        </h2>\r\n        <InfiniteScroll\r\n          className=\"infinite-scroll__wrapper\"\r\n          pageStart={0}\r\n          loadMore={loadMorePositive}\r\n          hasMore={hasmoreItems}\r\n          loader={\r\n            <div className=\"loader\" key={0}>\r\n              Loading ...\r\n            </div>\r\n          }\r\n          useWindow={false}\r\n          getScrollParent={() =>\r\n            document.getElementsByClassName('infinite-scroll')[0]\r\n          }\r\n        >\r\n          {positiveComments &&\r\n            positiveComments.map((comment) => {\r\n              return (\r\n                <div className=\"comment\" key={uuidv4()}>\r\n                  <div className=\"comment__text\">{`\"${comment[0]}\"`}</div>\r\n                  <div className=\"comment__sentiment\">\r\n                    {comment[3].toString().slice(0, 6)}\r\n                  </div>\r\n                </div>\r\n              );\r\n            })}\r\n        </InfiniteScroll>\r\n      </div>\r\n      <div className=\"infinite-scroll\">\r\n        <h2 className=\"infinite-scroll__heading\">\r\n          Selected negative sentiments:\r\n        </h2>\r\n        <InfiniteScroll\r\n          className=\"infinite-scroll__wrapper\"\r\n          pageStart={0}\r\n          loadMore={loadMoreNegative}\r\n          hasMore={hasmoreItems}\r\n          loader={\r\n            <div className=\"loader\" key={0}>\r\n              Loading ...\r\n            </div>\r\n          }\r\n          useWindow={false}\r\n          getScrollParent={() =>\r\n            document.getElementsByClassName('infinite-scroll')[1]\r\n          }\r\n        >\r\n          {negativeComments &&\r\n            negativeComments.map((comment) => {\r\n              return (\r\n                <div className=\"comment\" key={uuidv4()}>\r\n                  <div className=\"comment__text\">{`\"${comment[0]}\"`}</div>\r\n                  <div className=\"comment__sentiment\">\r\n                    {comment[3].toString().slice(0, 6)}\r\n                  </div>\r\n                </div>\r\n              );\r\n            })}\r\n        </InfiniteScroll>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default InfiniteScrollWindow;\r\n","import React from 'react';\r\nimport { useSelector } from 'react-redux';\r\nimport Bubblechart from './Bubblechart';\r\nimport MaxComments from './MaxComments';\r\nimport InfiniteScrollWindow from './InfiniteScrollWindow';\r\n\r\nfunction Display() {\r\n  const sentiment = useSelector((state) => state.sentiment.sentiment);\r\n  const sentimentCount = useSelector((state) => state.sentiment.sentimentCount);\r\n  const highestComment = useSelector((state) => state.sentiment.highestComment);\r\n  const lowestComment = useSelector((state) => state.sentiment.lowestComment);\r\n  const videoTitle = useSelector((state) => state.videoTitle);\r\n  const keyCounts = useSelector((state) => state.keyCounts);\r\n  const singleWordSentiments = useSelector(\r\n    (state) => state.singleWordSentiments\r\n  );\r\n\r\n  if (!sentiment) return null;\r\n  return (\r\n    <div className=\"display\">\r\n      <h2 className=\"display__title-name\">{videoTitle}</h2>\r\n      <MaxComments\r\n        sentimentCount={sentimentCount}\r\n        lowestComment={lowestComment}\r\n        highestComment={highestComment}\r\n        sentiment={sentiment}\r\n      />\r\n      <InfiniteScrollWindow />\r\n      <Bubblechart data={keyCounts} dataSingleWords={singleWordSentiments} />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Display;\r\n","import React from 'react';\nimport Search from './components/Search';\nimport Display from './components/Display';\n\nfunction App() {\n  return (\n    <div className=\"app\">\n      <h1 className=\"app__page-title\">Consensus</h1>\n      <p className=\"app__subheading\">AFINN Youtube Sentiment Analysis</p>\n      <Search />\n      <Display />\n    </div>\n  );\n}\n\nexport default App;\n","import {\r\n  SET_SENTIMENT,\r\n  SET_SENTIMENT_COUNT,\r\n  SET_HIGHEST_COMMENT,\r\n  SET_LOWEST_COMMENT,\r\n  SET_COMMENT_COUNT,\r\n} from '../actions/constants';\r\n\r\nconst initialState = {\r\n  sentiment: 0,\r\n  sentimentCount: [null, null],\r\n  highestComment: '',\r\n  lowestComment: '',\r\n  commentCount: 0,\r\n};\r\n\r\nexport const sentiment = (state = initialState, action) => {\r\n  switch (action.type) {\r\n    case SET_SENTIMENT:\r\n      return {\r\n        ...state,\r\n        sentiment: action.sentiment,\r\n      };\r\n    case SET_SENTIMENT_COUNT:\r\n      return {\r\n        ...state,\r\n        sentimentCount: action.sentimentCount,\r\n      };\r\n    case SET_HIGHEST_COMMENT:\r\n      return {\r\n        ...state,\r\n        highestComment: action.highestComment,\r\n      };\r\n    case SET_LOWEST_COMMENT:\r\n      return {\r\n        ...state,\r\n        lowestComment: action.lowestComment,\r\n      };\r\n    case SET_COMMENT_COUNT:\r\n      return {\r\n        ...state,\r\n        commentCount: action.commentCount,\r\n      };\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n","import {\r\n  SET_HIGHEST_SENTIMENT_SINGLE_WORDS,\r\n  SET_LOWEST_SENTIMENT_SINGLE_WORDS,\r\n} from '../actions/constants';\r\n\r\nconst initialState = {\r\n  highestSingleWords: [],\r\n  lowestSingleWords: [],\r\n};\r\n\r\nexport const singleWordSentiments = (state = initialState, action) => {\r\n  switch (action.type) {\r\n    case SET_HIGHEST_SENTIMENT_SINGLE_WORDS:\r\n      return {\r\n        ...state,\r\n        highestSingleWords: action.highestSingleWords,\r\n      };\r\n    case SET_LOWEST_SENTIMENT_SINGLE_WORDS:\r\n      return {\r\n        ...state,\r\n        lowestSingleWords: action.lowestSingleWords,\r\n      };\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n","import { combineReducers } from 'redux';\r\nimport { videoTitle } from './videoTitle';\r\nimport { sentiment } from './sentiment';\r\nimport { keyCounts } from './keyCounts';\r\nimport { comments } from './comments';\r\nimport { highestAndLowestCommentCount } from './highestAndLowestCommentCount';\r\nimport { singleWordSentiments } from './singleWordSentiments';\r\nimport { choice } from './choice';\r\n\r\nexport default combineReducers({\r\n  videoTitle,\r\n  sentiment,\r\n  keyCounts,\r\n  comments,\r\n  highestAndLowestCommentCount,\r\n  singleWordSentiments,\r\n  choice,\r\n});\r\n","import { SET_VIDEO_TITLE } from '../actions/constants';\r\n\r\nexport const videoTitle = (state = '', action) => {\r\n  switch (action.type) {\r\n    case SET_VIDEO_TITLE:\r\n      return action.videoTitle;\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n","import { SET_KEYCOUNTS } from '../actions/constants';\r\n\r\nexport const keyCounts = (state = {}, action) => {\r\n  switch (action.type) {\r\n    case SET_KEYCOUNTS:\r\n      return action.keyCounts;\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n","import { SET_COMMENTS } from '../actions/constants';\r\n\r\nexport const comments = (state = {}, action) => {\r\n  switch (action.type) {\r\n    case SET_COMMENTS:\r\n      return action.comments;\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n","import { SET_HIGHEST_AND_LOWEST_COMMENT_COUNT } from '../actions/constants';\r\n\r\nexport const highestAndLowestCommentCount = (state = {}, action) => {\r\n  switch (action.type) {\r\n    case SET_HIGHEST_AND_LOWEST_COMMENT_COUNT:\r\n      return action.highLowCommentCount;\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n","import { SET_CHOICE } from '../actions/constants';\r\n\r\nexport const choice = (state = 'keywords', action) => {\r\n  switch (action.type) {\r\n    case SET_CHOICE:\r\n      return action.choice;\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n","import { createStore, applyMiddleware } from 'redux';\r\nimport { composeWithDevTools } from 'redux-devtools-extension';\r\nimport thunk from 'redux-thunk';\r\nimport rootReducer from '../reducers';\r\n\r\nconst initialState = {};\r\n\r\nconst middleware = [thunk];\r\n\r\nconst store = createStore(\r\n  rootReducer,\r\n  initialState,\r\n  composeWithDevTools(applyMiddleware(...middleware))\r\n);\r\n\r\nexport default store;\r\n","import 'react-app-polyfill/ie9';\nimport 'react-app-polyfill/stable';\nimport 'core-js/stable';\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport store from './store';\nimport { Provider } from 'react-redux';\nimport './styles/main.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}