{"version":3,"sources":["actions/setVideoTitle.ts","actions/constants.ts","actions/setComments.ts","actions/setSentiments.ts","components/helper/keywords_helper.ts","components/helper/likes_helper.ts","components/helper/sentiments_helper.ts","components/helper/fetchComments_helper.js","components/helper/fetchVideoTitle_helper.ts","components/helper/cleanComments_helper.ts","components/SearchStyles.tsx","components/NoCommentsModal.tsx","actions/toggleNoCommentsModal.ts","components/Search.tsx","components/helper/shoertenToVideoID_helper.ts","actions/setSingleWordSentiments.ts","actions/setHighestAndLowestCommentCount.ts","actions/setKeycounts.ts","components/Resizeobserver.js","components/Bubblechart.js","actions/setChoice.ts","components/HighestLowestAverage.tsx","components/helper/filterComments_helper.ts","components/InfiniteScrollWindow.tsx","components/Display.tsx","App.tsx","reducers/sentiment.ts","reducers/comments.ts","reducers/singleWordSentiments.ts","reducers/index.ts","reducers/videoTitle.ts","reducers/keyCounts.ts","reducers/highestAndLowestCommentCount.ts","reducers/choice.ts","reducers/noCommentsModal.ts","store/index.ts","index.tsx"],"names":["setVideoTitle","videoTitle","type","setComments","comments","setCommentCount","commentCount","keyword_extractor","require","countKeywords","keywords","uniqueKeywords","i","length","word","toLowerCase","indexOf","push","keyCount","keyword","getKeywordsFromComments","extraction","extract","language","remove_digits","return_changed_case","remove_duplicates","findLikesForHighestAndLowestComment","highest","lowest","highestCommentLikes","lowestCommentLikes","comment","Analyzer","SentimentAnalyzer","stemmer","PorterStemmer","analyzer","singleWordSentiments","tokenized","lowWords","highWords","sentimentSingle","j","obj","sentiment","parseFloat","getSentiment","sentiments","highestLowestWords","split","getHighestAndLowestSingleWordSentiments","wholeWordSentiments","sentimentCount","isNaN","getWholeCommentSentiment","highestComment","lowestComment","apiKey","process","fetchComments","videoID","ID","a","textArr","token","undefined","maxResults","url","fetch","response","json","data","error","code","nextPageToken","map","splitcomment","fetchVideoTitle","title","cleanComments","cleanedComments","SearchStyles","makeStyles","theme","searchIcon","color","position","right","cursor","fontSize","NoCommentsModal","dispatch","useDispatch","className","onClick","connect","state","noCommentsModal","props","useState","videoLink","updateVideoLink","updateVideoID","useEffect","link","equalSignIndex","search","slice","shoertenToVideoID","getSearchResults","e","preventDefault","flat","sentimentCollector","lowestSingleWords","highestSingleWords","likes","highLowCommentCount","uniqueKeywordCounts","keyCounts","classes","placeholder","id","name","onChange","target","value","useResizeObserver","ref","dimensions","setDimensions","observeTarget","current","resizeObserver","ResizeObserver","entries","forEach","entry","contentRect","observe","unobserve","Bubblechart","dataSingleWords","console","log","svgRef","useRef","wrapperRef","Object","scoreValues","newEntries","Number","sort","b","bubbleCount","window","innerWidth","getBubbleCount","filter","arr","heighestXEntries","cleanEntries","amount","sentimentWordsCombined","category","keys","bubbles2Count","width","count","key","minValue","maxValue","choice","updateChoice","dataChoice","useCallback","minMaxNumbers","d3","svg","select","mouseEnter","selectAll","join","enter","append","attr","node","element","height","style","colorScale","colorScaleS","text","x","scaleOrdinal","domain","Set","range","scaleLinear","scaleBubbles","scaleL","scaleLS","xCenter","forceSimulation","force","forceManyBody","strength","d","forceCenter","forceCollide","radius","Math","abs","on","y","remove","handleChange","setChoice","document","getElementById","classList","add","HighestLowestAverage","useSelector","highestAndLowestCommentCount","styleHighest","styleLowest","average","output","heading","uuidv4","toString","reduce","generateSentimentField","sortCommentsBySentiment","indicator","sorted","values","commentsCopy","index","reverse","usedIndexes","InfiniteScrollWindow","commentsFiltered","setCommentsFiltered","positiveComments","setPositiveComments","negativeComments","setNegativeComments","hasmoreItems","setHasmoreItems","positive","negative","filterComments","pageStart","loadMore","hasMore","loader","useWindow","Display","App","initialState","NaN","rootReducer","combineReducers","action","middleware","thunk","store","createStore","composeWithDevTools","applyMiddleware","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.40ace50f.chunk.js","sourcesContent":["import { SET_VIDEO_TITLE, AppActions } from './constants';\r\n\r\nexport const setVideoTitle = (videoTitle: string): AppActions => ({\r\n  type: SET_VIDEO_TITLE,\r\n  videoTitle,\r\n});\r\n","import { SingleWords } from '../components/types/SingleWord';\nimport { HighLowCommentCount, Comment } from '../components/types/Comment';\nimport { KeyCounts } from '../components/types/KeyCounts';\nimport { Choice } from '../components/types/Choice';\nimport {\n  HighLowComment,\n  SentimentCount,\n  Sentiment,\n  CommentCount,\n} from '../components/types/Comment';\n\nexport const SET_VIDEO_TITLE = 'SET_VIDEO_TITLE';\nexport const SET_SENTIMENT = 'SET_SENTIMENT';\nexport const SET_SENTIMENT_COUNT = 'SET_SENTIMENT_COUNT';\nexport const SET_HIGHEST_COMMENT = 'SET_HIGHEST_COMMENT';\nexport const SET_LOWEST_COMMENT = 'SET_LOWEST_COMMENT';\nexport const SET_COMMENT_COUNT = 'SET_COMMENT_COUNT';\nexport const SET_CHOICE = 'SET_CHOICE';\nexport const SET_COMMENTS = 'SET_COMMENTS';\nexport const SET_HIGHEST_AND_LOWEST_COMMENT_COUNT =\n  'SET_HIGHEST_AND_LOWEST_COMMENT_COUNT';\nexport const SET_KEYCOUNTS = 'SET_KEYCOUNTS';\nexport const TOGGLE_NO_COMMENTS_MODAL = 'TOGGLE_NO_COMMENTS_MODAL';\nexport const SET_HIGHEST_SENTIMENT_SINGLE_WORDS =\n  'SET_HIGHEST_SENTIMENT_SINGLE_WORD';\nexport const SET_LOWEST_SENTIMENT_SINGLE_WORDS =\n  'SET_LOWEST_SENTIMENT_SINGLE_WORD';\n\nexport interface SetHighestSentimentSingleWords {\n  type: typeof SET_HIGHEST_SENTIMENT_SINGLE_WORDS;\n  highestSingleWords: SingleWords;\n}\n\nexport interface SetLowestSentimentSingleWords {\n  type: typeof SET_LOWEST_SENTIMENT_SINGLE_WORDS;\n  lowestSingleWords: SingleWords;\n}\n\nexport interface ToggleModal {\n  type: typeof TOGGLE_NO_COMMENTS_MODAL;\n}\n\nexport interface SetHighLowCommentCount {\n  type: typeof SET_HIGHEST_AND_LOWEST_COMMENT_COUNT;\n  highLowCommentCount: HighLowCommentCount;\n}\n\nexport interface SetKeyCounts {\n  type: typeof SET_KEYCOUNTS;\n  keyCounts: KeyCounts;\n}\n\nexport interface SetComments {\n  type: typeof SET_COMMENTS;\n  comments: Comment[];\n}\n\nexport interface setChoice {\n  type: typeof SET_CHOICE;\n  choice: Choice;\n}\n\nexport interface SetVideoTitle {\n  type: typeof SET_VIDEO_TITLE;\n  videoTitle: string;\n}\n\nexport interface SetSentiment {\n  type: typeof SET_SENTIMENT;\n  sentiment: Sentiment;\n}\n\nexport interface SetSentimentCount {\n  type: typeof SET_SENTIMENT_COUNT;\n  sentimentCount: SentimentCount;\n}\n\nexport interface SetHighestComment {\n  type: typeof SET_HIGHEST_COMMENT;\n  highestComment: HighLowComment;\n}\n\nexport interface SetLowestComment {\n  type: typeof SET_LOWEST_COMMENT;\n  lowestComment: HighLowComment;\n}\n\nexport interface SetCommentCount {\n  type: typeof SET_COMMENT_COUNT;\n  commentCount: CommentCount;\n}\n\nexport type CommentCountActionTypes = SetHighLowCommentCount;\n\nexport type VideoTitleActionTypes = SetVideoTitle;\n\nexport type ChartChoiceActionTypes = setChoice;\n\nexport type CommentsActionTypes = SetComments;\n\nexport type KeyCountsActionTypes = SetKeyCounts;\n\nexport type ModalActionTypes = ToggleModal;\n\nexport type SingleWordSentimentsActionTypes =\n  | SetHighestSentimentSingleWords\n  | SetLowestSentimentSingleWords;\n\nexport type SentimentActionTypes =\n  | SetSentiment\n  | SetSentimentCount\n  | SetHighestComment\n  | SetLowestComment\n  | SetCommentCount;\n\nexport type AppActions =\n  | SentimentActionTypes\n  | ChartChoiceActionTypes\n  | VideoTitleActionTypes\n  | CommentsActionTypes\n  | CommentCountActionTypes\n  | KeyCountsActionTypes\n  | ModalActionTypes\n  | SingleWordSentimentsActionTypes;\n","import { SET_COMMENTS, AppActions } from './constants';\r\nimport { Comment } from '../components/types/Comment';\r\n\r\nexport const setComments = (comments: Comment[]): AppActions => ({\r\n  type: SET_COMMENTS,\r\n  comments,\r\n});\r\n","import {\r\n  SET_SENTIMENT,\r\n  SET_SENTIMENT_COUNT,\r\n  SET_HIGHEST_COMMENT,\r\n  SET_LOWEST_COMMENT,\r\n  SET_COMMENT_COUNT,\r\n  AppActions,\r\n} from './constants';\r\nimport { SentimentCount, HighLowComment } from '../components/types/Comment';\r\n\r\nexport const setSentiment = (sentiment: number): AppActions => ({\r\n  type: SET_SENTIMENT,\r\n  sentiment,\r\n});\r\n\r\nexport const setSentimentCount = (\r\n  sentimentCount: SentimentCount\r\n): AppActions => ({\r\n  type: SET_SENTIMENT_COUNT,\r\n  sentimentCount,\r\n});\r\n\r\nexport const setHighestComment = (\r\n  highestComment: HighLowComment\r\n): AppActions => ({\r\n  type: SET_HIGHEST_COMMENT,\r\n  highestComment,\r\n});\r\n\r\nexport const setLowestComment = (\r\n  lowestComment: HighLowComment\r\n): AppActions => ({\r\n  type: SET_LOWEST_COMMENT,\r\n  lowestComment,\r\n});\r\n\r\nexport const setCommentCount = (commentCount: number): AppActions => ({\r\n  type: SET_COMMENT_COUNT,\r\n  commentCount,\r\n});\r\n","const keyword_extractor = require('keyword-extractor');\r\n\r\ntype keyCount = { [key: string]: number };\r\n/**\r\n * Counts Keywords for the bubblechart comparsion\r\n */\r\nexport const countKeywords = (keywords: string[][]): keyCount => {\r\n  // Get all the unique keywords\r\n  const uniqueKeywords: string[] = [];\r\n  for (let i = 0; i < keywords.length; i++) {\r\n    for (const keyword of keywords[i]) {\r\n      const word = keyword.toLowerCase();\r\n      uniqueKeywords.indexOf(word) === -1 && uniqueKeywords.push(word);\r\n    }\r\n  }\r\n\r\n  // Put all of them into an object an count them\r\n  const keyCount: keyCount = {};\r\n  for (let i = 0; i < keywords.length; i++) {\r\n    for (const keyword of keywords[i]) {\r\n      keyCount[keyword] && keyCount[keyword]++;\r\n      !keyCount[keyword] && (keyCount[keyword] = 1);\r\n    }\r\n  }\r\n  return keyCount;\r\n};\r\n\r\n/**\r\n * Gets english lang keywords with the help of keywordextractor\r\n * from all the comments for the bubblechart\r\n */\r\nexport const getKeywordsFromComments = (comments: string[]): string[][] => {\r\n  let keywords: string[][] = [];\r\n  for (let i = 0; i < comments.length; i++) {\r\n    let extraction: string[] = keyword_extractor.extract(comments[i], {\r\n      language: 'english',\r\n      remove_digits: true,\r\n      return_changed_case: true,\r\n      remove_duplicates: false,\r\n    });\r\n    keywords.push(extraction);\r\n  }\r\n  return keywords;\r\n};\r\n","/**\r\n * Takes the highest and lowest comments and gets the like count\r\n */\r\n\r\ntype comment = [number, string];\r\n\r\ntype comments = [string, number, string, number, string, number?][];\r\n\r\nexport const findLikesForHighestAndLowestComment = (\r\n  highest: comment,\r\n  lowest: comment,\r\n  comments: comments\r\n): [number, number] => {\r\n  let highestCommentLikes = 0;\r\n  let lowestCommentLikes = 0;\r\n  for (const comment of comments) {\r\n    if (comment[0] === highest[1]) {\r\n      highestCommentLikes = comment[1];\r\n    }\r\n    if (comment[0] === lowest[1]) {\r\n      lowestCommentLikes = comment[1];\r\n    }\r\n  }\r\n  return [highestCommentLikes, lowestCommentLikes];\r\n};\r\n","import { SingleWord } from '../types/SingleWord';\r\nvar Analyzer = require('natural').SentimentAnalyzer;\r\nvar stemmer = require('natural').PorterStemmer;\r\nconst analyzer = new Analyzer('English', stemmer, 'afinn');\r\n\r\n/**\r\n * Goes through all the comments and finds words <= -1 or >= 1 and puts them in an array\r\n * Counts positive, neutral and negative comments\r\n * Finds the highest and lowest sentiment comments\r\n * Gets the overall sentiment\r\n */\r\n\r\nconst singleWordSentiments = (\r\n  tokenized: string[],\r\n  lowWords: SingleWord[],\r\n  highWords: SingleWord[]\r\n): void => {\r\n  let sentimentSingle;\r\n  for (let j = 0; j < tokenized.length; j++) {\r\n    sentimentSingle = parseFloat(analyzer.getSentiment([tokenized[j]]));\r\n    let obj: { word: string; sentiment: number } = { word: '', sentiment: 0 };\r\n    if (sentimentSingle <= -1) {\r\n      obj['word'] = tokenized[j];\r\n      obj['sentiment'] = sentimentSingle;\r\n      lowWords.push(obj);\r\n    } else if (sentimentSingle >= 1) {\r\n      obj['word'] = tokenized[j];\r\n      obj['sentiment'] = sentimentSingle;\r\n      highWords.push(obj);\r\n    }\r\n  }\r\n};\r\n\r\ntype getWholeCommentSentiment = [\r\n  [number, string],\r\n  [number, string],\r\n  [number, number, number],\r\n  number\r\n];\r\n\r\nconst getWholeCommentSentiment = (\r\n  comments: string[],\r\n  length: number\r\n): getWholeCommentSentiment => {\r\n  const analyzer = new Analyzer('English', stemmer, 'afinn');\r\n\r\n  let highest: [number, string] = [-10, ''];\r\n  let lowest: [number, string] = [10, ''];\r\n  let sentimentCount: [number, number, number] = [0, 0, 0];\r\n  let sentiments = 0;\r\n\r\n  for (let i = 0; i < length; i++) {\r\n    let tokenized = comments[i].split(' ');\r\n    const sentiment = parseFloat(analyzer.getSentiment(tokenized));\r\n\r\n    sentiment > 0 && sentimentCount[2]++;\r\n    sentiment === 0 && sentimentCount[1]++;\r\n    sentiment < 0 && sentimentCount[0]++;\r\n\r\n    sentiment > highest[0] &&\r\n      (highest[0] = sentiment) &&\r\n      (highest[1] = comments[i]);\r\n    sentiment < lowest[0] &&\r\n      (lowest[0] = sentiment) &&\r\n      (lowest[1] = comments[i]);\r\n\r\n    if (!isNaN(sentiment)) {\r\n      sentiments += sentiment;\r\n    }\r\n  }\r\n  return [highest, lowest, sentimentCount, sentiments];\r\n};\r\n\r\nconst getHighestAndLowestSingleWordSentiments = (\r\n  comments: string[],\r\n  length: number\r\n): [SingleWord[], SingleWord[]] => {\r\n  // Array of objects collecting words <= -1 or >= 1\r\n  let lowWords: SingleWord[] = [];\r\n  let highWords: SingleWord[] = [];\r\n\r\n  for (let i = 0; i < length; i++) {\r\n    let tokenized = comments[i].split(' ');\r\n    // Get the single word sentiments\r\n    singleWordSentiments(tokenized, lowWords, highWords);\r\n  }\r\n\r\n  return [highWords, lowWords];\r\n};\r\n\r\nexport const sentiments = (\r\n  comments: string[]\r\n): [\r\n  number,\r\n  [number, number, number],\r\n  [number, string],\r\n  [number, string],\r\n  SingleWord[],\r\n  SingleWord[]\r\n] => {\r\n  let length = comments.length;\r\n  const highestLowestWords = getHighestAndLowestSingleWordSentiments(\r\n    comments,\r\n    length\r\n  );\r\n  const highWords = highestLowestWords[0];\r\n  const lowWords = highestLowestWords[1];\r\n\r\n  const wholeWordSentiments = getWholeCommentSentiment(comments, length);\r\n  const highestComment = wholeWordSentiments[0];\r\n  const lowestComment = wholeWordSentiments[1];\r\n  const sentimentCount = wholeWordSentiments[2];\r\n  const sentiments = wholeWordSentiments[3];\r\n  return [\r\n    sentiments / length,\r\n    sentimentCount,\r\n    highestComment,\r\n    lowestComment,\r\n    lowWords,\r\n    highWords,\r\n  ];\r\n};\r\n","var Analyzer = require('natural').SentimentAnalyzer;\r\nvar stemmer = require('natural').PorterStemmer;\r\nlet apiKey = process.env.REACT_APP_API_KEY;\r\n\r\n// Connection to the youtube API -> setup to get more then 100 comments (all the comments f.e.) but too much api cost atm\r\nexport const fetchComments = (videoID) => {\r\n  let ID = videoID;\r\n  let maxResults = 100;\r\n  let analyzer = new Analyzer('English', stemmer, 'afinn');\r\n\r\n  // Recursive Function to get each 100 comments\r\n  async function fetchComments(textArr = [], token) {\r\n    // If there are X comments already in array return array\r\n    if (textArr[0] !== undefined) {\r\n      // Every array has 100 comments in it so maxResults / 100 >= textArr.length tests if the maxResult-propertie is fullfilled\r\n      if (maxResults / 100 >= textArr.length) {\r\n        return textArr;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Change the url based on the existence of a nextpagetoken\r\n     * Setup and working for future use but API cost was too high\r\n     */\r\n    let url;\r\n    if (token) {\r\n      url = `https://www.googleapis.com/youtube/v3/commentThreads?key=${apiKey}&textFormat=plainText&part=snippet&videoId=${ID}&maxResults=${maxResults}&pageToken=${token}`;\r\n    } else {\r\n      url = `https://www.googleapis.com/youtube/v3/commentThreads?key=${apiKey}&textFormat=plainText&part=snippet&videoId=${ID}&maxResults=${maxResults}`;\r\n    }\r\n\r\n    // Grab the data and get comment and likecount for comment\r\n    let comments, nextPageToken;\r\n\r\n    const response = await fetch(url);\r\n    const data = await response.json();\r\n    if (data.error && data.error.code === 403) {\r\n      return false;\r\n    }\r\n    nextPageToken = await data['nextPageToken'];\r\n    comments = await data['items'];\r\n\r\n    // If the address was f.e. empty and there are no results just return []\r\n    if (!comments) return [];\r\n\r\n    // Else put the comments and the likecount (not used yet) into an array\r\n    comments = comments.map((comment) => {\r\n      const splitcomment = comment['snippet']['topLevelComment']['snippet'][\r\n        'textDisplay'\r\n      ].split(' ');\r\n      return [\r\n        comment['snippet']['topLevelComment']['snippet']['textDisplay'],\r\n        comment['snippet']['topLevelComment']['snippet']['likeCount'],\r\n        comment['snippet']['topLevelComment']['snippet']['authorChannelId'][\r\n          'value'\r\n        ],\r\n        analyzer.getSentiment(splitcomment),\r\n        comment['snippet']['topLevelComment']['snippet']['authorChannelUrl'],\r\n      ];\r\n    });\r\n\r\n    // Push data to array that is passed along\r\n    textArr.push(comments);\r\n\r\n    /**\r\n     * If there is one more comment page to load grab the nextpagetoken for that site\r\n     * Not used as it eats the free api usage too quickly. Could grab all other comments\r\n     * If used\r\n     */\r\n    if (nextPageToken) {\r\n      return fetchComments(textArr, nextPageToken);\r\n    }\r\n\r\n    // Or else just return the array\r\n    else if (!nextPageToken) return textArr;\r\n  }\r\n\r\n  return fetchComments([], null);\r\n};\r\n","/**\r\n * Uses the noembed site to get the video title, reduces api cost\r\n */\r\n\r\ninterface Comments {\r\n  author_url: string;\r\n  type: string;\r\n  provider_url: string;\r\n  thumbnail_height: number;\r\n  width: number;\r\n  provider_name: string;\r\n  url: string;\r\n  author_name: string;\r\n  title: string;\r\n  thumbnail_width: number;\r\n  thumbnail_url: string;\r\n  height: number;\r\n  version: string;\r\n  html: string;\r\n}\r\n\r\nexport const fetchVideoTitle = async (ID: string) => {\r\n  if (ID && ID !== undefined) {\r\n    const url: string = `https://noembed.com/embed?url=https%3A%2F%2Fhttps://www.youtube.com/watch?v=${ID}`;\r\n    const response = await fetch(url);\r\n    const data: Comments = await response.json();\r\n    const title: string = data['title'];\r\n    return title;\r\n  }\r\n  return null;\r\n};\r\n","/**\r\n * Seperates the pure text from additional information wich are not needed in this step\r\n */\r\n\r\nexport const cleanComments = (\r\n  comments: [string, number, string, number, string][]\r\n) => {\r\n  let cleanedComments = [];\r\n  for (let i = 0; i < comments.length; i++) {\r\n    cleanedComments.push(comments[i][0]);\r\n  }\r\n  return cleanedComments;\r\n};\r\n","//MUI\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nexport const SearchStyles = makeStyles((theme) => ({\r\n  searchIcon: {\r\n    color: 'rgba(128, 128, 128, 0.5)',\r\n    position: 'absolute',\r\n    right: '10px',\r\n    cursor: 'pointer',\r\n    fontSize: '2.25rem',\r\n  },\r\n}));\r\n","import React from 'react';\r\nimport { useDispatch } from 'react-redux';\r\n\r\nimport { toggleNoCommentsModal } from '../actions/toggleNoCommentsModal';\r\n\r\nconst NoCommentsModal: React.FC = () => {\r\n  const dispatch = useDispatch();\r\n  return (\r\n    <div className=\"no-comments-modal\">\r\n      <div\r\n        className=\"no-comments-modal__close-button\"\r\n        onClick={() => dispatch(toggleNoCommentsModal())}\r\n      >\r\n        CLOSE X\r\n      </div>\r\n      <div className=\"no-comments-modal__text\">\r\n        The video has no comments or comments are deactivated, sry :(\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default NoCommentsModal;\r\n","import { TOGGLE_NO_COMMENTS_MODAL, AppActions } from './constants';\r\n\r\nexport const toggleNoCommentsModal = (): AppActions => ({\r\n  type: TOGGLE_NO_COMMENTS_MODAL,\r\n});\r\n","import React, { useState, useEffect } from 'react';\r\nimport { useDispatch } from 'react-redux';\r\nimport { connect } from 'react-redux';\r\nimport { AppState } from '../reducers';\r\n\r\n//MUI\r\nimport SearchIcon from '@material-ui/icons/Search';\r\n\r\n//Actions\r\nimport { setKeycounts } from '../actions/setKeycounts';\r\nimport { setVideoTitle } from '../actions/setVideoTitle';\r\nimport { setComments } from '../actions/setComments';\r\nimport { setHighestAndLowestCommentCount } from '../actions/setHighestAndLowestCommentCount';\r\nimport { toggleNoCommentsModal } from '../actions/toggleNoCommentsModal';\r\nimport {\r\n  setHighestSingleWords,\r\n  setLowestSingleWords,\r\n} from '../actions/setSingleWordSentiments';\r\nimport {\r\n  setSentiment,\r\n  setSentimentCount,\r\n  setHighestComment,\r\n  setLowestComment,\r\n  setCommentCount,\r\n} from '../actions/setSentiments';\r\n\r\n//Helper\r\nimport { getKeywordsFromComments } from './helper/keywords_helper';\r\nimport { countKeywords } from './helper/keywords_helper';\r\nimport { findLikesForHighestAndLowestComment } from './helper/likes_helper';\r\nimport { sentiments } from './helper/sentiments_helper';\r\nimport { fetchComments } from './helper/fetchComments_helper';\r\nimport { fetchVideoTitle } from './helper/fetchVideoTitle_helper';\r\nimport { cleanComments } from './helper/cleanComments_helper';\r\nimport { shoertenToVideoID } from './helper/shoertenToVideoID_helper';\r\n\r\n//Assets\r\nimport { SearchStyles } from './SearchStyles';\r\n\r\n//Components\r\nimport NoCommentsModal from './NoCommentsModal';\r\n\r\ninterface Props {\r\n  noCommentsModal: boolean;\r\n}\r\n\r\nfunction Search(props: Props) {\r\n  const noCommentsModal = props.noCommentsModal;\r\n  const [videoLink, updateVideoLink] = useState<string>('');\r\n  const [videoID, updateVideoID] = useState<string>('');\r\n  const dispatch = useDispatch();\r\n\r\n  useEffect(() => {\r\n    // Get and Update Video ID when videoLink updates\r\n    const ID = shoertenToVideoID(videoLink);\r\n    updateVideoID(ID);\r\n  }, [videoLink]);\r\n\r\n  // Main knot to get all needed information from the api\r\n  const getSearchResults = async (e: React.MouseEvent) => {\r\n    e.preventDefault();\r\n    // Get and set Video Title\r\n    if (videoID !== undefined) {\r\n      let videoTitle: string | null = await fetchVideoTitle(videoID);\r\n      if (videoTitle !== null) {\r\n        dispatch(setVideoTitle(videoTitle));\r\n      }\r\n    } else return null;\r\n    // Get last 100 comments (YT always returns 100 if there are at least 100 comments)\r\n    let comments = await fetchComments(videoID);\r\n    //Method returns false when comments are deactivated\r\n    if (!comments || comments.length === 0) {\r\n      return dispatch(toggleNoCommentsModal());\r\n    }\r\n    if (comments.length === 0) return;\r\n    comments = comments.flat();\r\n    dispatch(setComments(comments));\r\n\r\n    // Extract pure comments from [comment, likes, id]\r\n    let cleanedComments = cleanComments(comments);\r\n    let commentCount = cleanedComments.length;\r\n    dispatch(setCommentCount(commentCount));\r\n\r\n    // Calculate the sentiment and update\r\n    let sentimentCollector = sentiments(cleanedComments);\r\n    dispatch(setSentiment(sentimentCollector[0]));\r\n    dispatch(setSentimentCount(sentimentCollector[1]));\r\n    dispatch(setHighestComment(sentimentCollector[2]));\r\n    dispatch(setLowestComment(sentimentCollector[3]));\r\n    dispatch(setLowestSingleWords(sentimentCollector[4]));\r\n    dispatch(setHighestSingleWords(sentimentCollector[5]));\r\n\r\n    // Get and set the likes for the highest and lowest sentiment comments\r\n    let likes = findLikesForHighestAndLowestComment(\r\n      sentimentCollector[2],\r\n      sentimentCollector[3],\r\n      comments\r\n    );\r\n    dispatch(setHighestAndLowestCommentCount(likes));\r\n\r\n    // Get all the keywords from all the comments and count them\r\n    let keywords = getKeywordsFromComments(cleanedComments);\r\n    let uniqueKeywordCounts = countKeywords(keywords);\r\n    dispatch(setKeycounts(uniqueKeywordCounts));\r\n  };\r\n\r\n  const classes = SearchStyles();\r\n  return (\r\n    <div className=\"search\">\r\n      <form className=\"search__form\">\r\n        <input\r\n          placeholder=\"Enter Youtube Video Link...\"\r\n          type=\"text\"\r\n          id=\"video-link\"\r\n          name=\"video-link\"\r\n          onChange={(e) => updateVideoLink(e.target.value)}\r\n          value={videoLink}\r\n          className=\"search__link-input\"\r\n        />\r\n        <SearchIcon className={classes.searchIcon} onClick={getSearchResults} />\r\n      </form>\r\n      <button\r\n        onClick={getSearchResults}\r\n        value=\"Search\"\r\n        className=\"search__button\"\r\n      >\r\n        Search\r\n      </button>\r\n      {noCommentsModal && <NoCommentsModal />}\r\n    </div>\r\n  );\r\n}\r\n\r\ninterface StateProps {\r\n  noCommentsModal: boolean;\r\n}\r\n\r\nconst mapStateToProps = (state: AppState): StateProps => ({\r\n  noCommentsModal: state.noCommentsModal,\r\n});\r\n\r\nexport default connect(mapStateToProps)(Search);\r\n","/**\r\n * Takes the video link and returns the ID\r\n */\r\nexport const shoertenToVideoID = (link: string) => {\r\n  const equalSignIndex = link.search('=');\r\n  const videoID = link.slice(equalSignIndex + 1);\r\n  return videoID;\r\n};\r\n","import {\r\n  SET_HIGHEST_SENTIMENT_SINGLE_WORDS,\r\n  SET_LOWEST_SENTIMENT_SINGLE_WORDS,\r\n  AppActions,\r\n} from './constants';\r\nimport { SingleWord } from '../components/types/SingleWord';\r\n\r\nexport const setHighestSingleWords = (\r\n  highestSingleWords: SingleWord[]\r\n): AppActions => ({\r\n  type: SET_HIGHEST_SENTIMENT_SINGLE_WORDS,\r\n  highestSingleWords,\r\n});\r\n\r\nexport const setLowestSingleWords = (\r\n  lowestSingleWords: SingleWord[]\r\n): AppActions => ({\r\n  type: SET_LOWEST_SENTIMENT_SINGLE_WORDS,\r\n  lowestSingleWords,\r\n});\r\n","import { SET_HIGHEST_AND_LOWEST_COMMENT_COUNT, AppActions } from './constants';\r\nimport { HighLowCommentCount } from '../components/types/Comment';\r\n\r\nexport const setHighestAndLowestCommentCount = (\r\n  highLowCommentCount: HighLowCommentCount\r\n): AppActions => ({\r\n  type: SET_HIGHEST_AND_LOWEST_COMMENT_COUNT,\r\n  highLowCommentCount,\r\n});\r\n","import { SET_KEYCOUNTS, AppActions } from './constants';\r\nimport { KeyCounts } from '../components/types/KeyCounts';\r\n\r\nexport const setKeycounts = (keyCounts: KeyCounts): AppActions => ({\r\n  type: SET_KEYCOUNTS,\r\n  keyCounts,\r\n});\r\n","import ResizeObserver from 'resize-observer-polyfill';\r\nimport { useEffect, useState } from 'react';\r\n\r\nconst useResizeObserver = (ref) => {\r\n  const [dimensions, setDimensions] = useState(null);\r\n  useEffect(() => {\r\n    const observeTarget = ref.current;\r\n    const resizeObserver = new ResizeObserver((entries) => {\r\n      entries.forEach((entry) => {\r\n        setDimensions(entry.contentRect);\r\n      });\r\n    });\r\n    resizeObserver.observe(observeTarget);\r\n    return () => {\r\n      resizeObserver.unobserve(observeTarget);\r\n    };\r\n  }, [ref]);\r\n  return dimensions;\r\n};\r\n\r\nexport default useResizeObserver;\r\n","import * as d3 from 'd3';\r\nimport {\r\n  select,\r\n  forceSimulation,\r\n  scaleOrdinal,\r\n  forceCollide,\r\n  forceManyBody,\r\n  forceCenter,\r\n  scaleLinear,\r\n} from 'd3';\r\nimport React, { useRef, useEffect, useState, useCallback } from 'react';\r\nimport useResizeObserver from './Resizeobserver';\r\nimport { useDispatch } from 'react-redux';\r\nimport { setChoice } from '../actions/setChoice';\r\n\r\nfunction Bubblechart({ data, dataSingleWords }) {\r\n  console.log(data);\r\n  const svgRef = useRef();\r\n  const wrapperRef = useRef();\r\n  const dimensions = useResizeObserver(wrapperRef);\r\n  const entries = Object.entries(data);\r\n  const alphabet = 'abcdefghijklmnopqrstuvwxyz1234567890';\r\n  const dispatch = useDispatch();\r\n\r\n  let scoreValues = [];\r\n\r\n  const getBubbleCount = () => {\r\n    let bubbleCount = 25;\r\n    if (window.innerWidth < 700) bubbleCount = 15;\r\n    return bubbleCount;\r\n  };\r\n\r\n  const heighestXEntries = () => {\r\n    // Get all unique counts for a word and sort them\r\n    for (let entry of entries) {\r\n      if (scoreValues.indexOf(entry[1]) === -1)\r\n        scoreValues.push(Number(entry[1]));\r\n    }\r\n    scoreValues.sort((a, b) => a - b);\r\n\r\n    // goes backwards through the scores and pushes [word, count] into newEntries\r\n    let newEntries = [];\r\n    const bubbleCount = getBubbleCount();\r\n    for (let i = scoreValues.length; i > 0; i--) {\r\n      newEntries.push(\r\n        ...entries.filter((arr) => {\r\n          return arr[1] === scoreValues[i] && arr;\r\n        })\r\n      );\r\n      if (newEntries.length >= bubbleCount) break;\r\n    }\r\n    return newEntries.slice(0, bubbleCount);\r\n  };\r\n\r\n  let newEntries = heighestXEntries();\r\n\r\n  // Sorts the entries as object (for d3) into an array. Gets rid of single character mentions like = or -\r\n  let cleanEntries = [];\r\n  for (let entry of newEntries) {\r\n    if (entry[1] > 1) {\r\n      if (alphabet.indexOf(entry[0][0]) === -1) {\r\n        continue;\r\n      }\r\n      let obj = { word: null, amount: null };\r\n      obj['word'] = entry[0];\r\n      obj['amount'] = entry[1];\r\n      cleanEntries.push(obj);\r\n    }\r\n  }\r\n\r\n  // Merge Singlewordsentiments and assign category 0 or 1\r\n  let sentimentWordsCombined = [];\r\n  let category = 0;\r\n  let keys = Object.keys(dataSingleWords);\r\n\r\n  let bubbles2Count = 15;\r\n  if (dimensions && dimensions.width <= 700) bubbles2Count = 10;\r\n\r\n  let count = 0;\r\n\r\n  for (let key of keys) {\r\n    for (let i = 0; i < dataSingleWords[key].length; i++) {\r\n      if (count < bubbles2Count) {\r\n        let obj = dataSingleWords[key][i];\r\n        obj['category'] = category;\r\n        sentimentWordsCombined.push(obj);\r\n        count++;\r\n      }\r\n    }\r\n    count = 0;\r\n    category++;\r\n  }\r\n\r\n  // Base bubbles on choice of keywords or sentiment words\r\n  const [choice, updateChoice] = useState('keywords');\r\n  const dataChoice = useCallback(() => {\r\n    return choice === 'keywords' ? cleanEntries : sentimentWordsCombined;\r\n  }, [choice, cleanEntries, sentimentWordsCombined]);\r\n\r\n  // Gets the minValue and maxValue of word counts\r\n  let minValue;\r\n  let maxValue;\r\n\r\n  if (dataChoice().length !== 0) {\r\n    let minMaxNumbers = [];\r\n    for (let entry of dataChoice()) {\r\n      minMaxNumbers.push(entry['amount' || 'sentiment']);\r\n    }\r\n    minValue = d3.min(minMaxNumbers);\r\n    maxValue = d3.max(minMaxNumbers);\r\n  }\r\n\r\n  useEffect(() => {\r\n    let data = dataChoice();\r\n    if (!dimensions) return;\r\n    let svg = null;\r\n    svg = select(svgRef.current);\r\n\r\n    const mouseEnter = (value) => {\r\n      svg\r\n        .selectAll('.rec')\r\n        .data(() => {\r\n          if (choice === 'sentiment') {\r\n            return [[value['sentiment'], value['word']]];\r\n          } else return [[value['amount'], value['word']]];\r\n        })\r\n        .join((enter) => enter.append('rect'))\r\n        .attr('class', 'rec')\r\n        .attr('x', (node) => {\r\n          for (let element of cleanEntries) {\r\n            if (choice !== 'sentiment') {\r\n              if (element['word'] === node[1]) {\r\n                if (dimensions.width <= 700) {\r\n                  return dimensions.width / 2 - 175;\r\n                } else return element['x'] + 100;\r\n              }\r\n            } else return dimensions.width / 2 - (node[1].length * 4 + 150);\r\n          }\r\n        })\r\n        .attr('width', (node) => {\r\n          return `${node[1].length * 4 + 300}px`;\r\n        })\r\n        .attr('height', '40px')\r\n        .attr('text-anchor', 'middle')\r\n        .attr('y', (node) => {\r\n          for (let element of cleanEntries) {\r\n            if (choice !== 'sentiment') {\r\n              if (element['word'] === node[1]) {\r\n                return element['y'];\r\n              }\r\n            } else return dimensions.height / 2;\r\n          }\r\n        })\r\n        .attr('opacity', 1)\r\n        .attr('fill', 'white')\r\n        .style('stroke', (node) => {\r\n          if (choice !== 'sentiment') {\r\n            return colorScale(node[0]);\r\n          } else {\r\n            return colorScaleS(node[0]);\r\n          }\r\n        })\r\n        .style('stroke-width', 2)\r\n        .attr('rx', 4);\r\n      svg\r\n        .selectAll('.tooltip')\r\n        .data(() => {\r\n          if (choice === 'sentiment') {\r\n            return [[value['sentiment'], value['word']]];\r\n          } else return [[value['amount'], value['word']]];\r\n        })\r\n        .join((enter) => enter.append('text'))\r\n        .attr('class', 'tooltip')\r\n        .text((node) => {\r\n          if (choice === 'sentiment') {\r\n            return `sentiment: ${node[0]}, word: \"${node[1]}\"`;\r\n          } else return `${node[0]} times used: \"${node[1]}\"`;\r\n        })\r\n        .attr('x', (node) => {\r\n          let x = dimensions.width / 2;\r\n          for (let element of cleanEntries) {\r\n            if (element['word'] === node[1]) {\r\n              if (choice !== 'sentiment') {\r\n                if (dimensions.width <= 700) {\r\n                  x = dimensions.width / 2;\r\n                } else x = element['x'] + node[1].length * 4 + 200;\r\n              } else x = dimensions.width / 2;\r\n            }\r\n          }\r\n          return x;\r\n        })\r\n        .attr('text-anchor', 'middle')\r\n        .attr('y', (node) => {\r\n          for (let element of cleanEntries) {\r\n            if (choice !== 'sentiment') {\r\n              if (element['word'] === node[1]) {\r\n                return element['y'] + 25;\r\n              }\r\n            } else return dimensions.height / 2 + 25;\r\n          }\r\n        })\r\n        .attr('opacity', 1)\r\n        .attr('fill', 'black');\r\n    };\r\n    // Colors for Bubbles\r\n    const colorScale = scaleOrdinal()\r\n      .domain(new Set(scoreValues))\r\n      .range([\r\n        '#00e8e8',\r\n        '#F2CB05',\r\n        '#F28705',\r\n        '#D92818',\r\n        '#D94141',\r\n        '#0ba3ff',\r\n        '#6aafda',\r\n      ]);\r\n\r\n    const colorScaleS = scaleLinear()\r\n      .domain([-2, 2])\r\n      .range(['rgb(217, 29, 0)', 'rgb(66, 230, 0)']);\r\n\r\n    // Determines the scale based on screen size\r\n    let scaleBubbles = 1.3;\r\n    if (dimensions.width <= 700) scaleBubbles = 0.8;\r\n\r\n    // Scale for bubbles using scale var\r\n    const scaleL = d3\r\n      .scaleSqrt()\r\n      .domain([minValue, maxValue])\r\n      .range([25 * scaleBubbles, 60 * scaleBubbles]);\r\n\r\n    let scaleBubblesS = 2;\r\n\r\n    const scaleLS = d3\r\n      .scaleSqrt()\r\n      .domain([0, 5])\r\n      .range([0 * scaleBubblesS, 25 * scaleBubblesS]);\r\n    svg.style('width', '100%').style('height', '100%');\r\n\r\n    svg.attr('viewbox', `0 0 ${dimensions.width} ${dimensions.height}`);\r\n\r\n    const xCenter = [\r\n      dimensions.width / 4,\r\n      dimensions.width - dimensions.width / 4,\r\n    ];\r\n\r\n    const simulationBubbles = () => {\r\n      forceSimulation(data)\r\n        .force('charge', forceManyBody().strength(20))\r\n        .force(\r\n          'x',\r\n          choice === 'sentiment'\r\n            ? d3.forceX().x((d) => {\r\n                if (choice === 'sentiment') {\r\n                  return d['category'] === 0 ? xCenter[0] : xCenter[1];\r\n                }\r\n              })\r\n            : null\r\n        )\r\n        .force(\r\n          'center',\r\n          forceCenter(dimensions.width / 2, dimensions.height / 2)\r\n        )\r\n        .force(\r\n          'collide',\r\n          forceCollide().radius((node) => {\r\n            if (choice === 'sentiment') {\r\n              return scaleLS(Math.abs(Number(node['sentiment'])));\r\n            } else return scaleL(node['amount']);\r\n          })\r\n        )\r\n        .on('tick', () => {\r\n          svg\r\n            .selectAll('.node')\r\n            .data(data)\r\n            .join('circle')\r\n            .attr('class', 'node')\r\n            .attr('r', (node) => {\r\n              if (choice === 'sentiment') {\r\n                return scaleLS(Math.abs(Number(node['sentiment'])));\r\n              } else return scaleL(node['amount']);\r\n            })\r\n            .style('fill', (node) => {\r\n              if (choice === 'sentiment') {\r\n                return colorScaleS(node['sentiment']);\r\n              } else return colorScale(node['amount']);\r\n            })\r\n            .attr('cx', (node) => node.x)\r\n            .attr('cy', (node) => node.y)\r\n            .on('mouseenter', (value) => {\r\n              mouseEnter(value);\r\n            })\r\n            .on('mouseleave', () => {\r\n              svg.selectAll('.tooltip').remove();\r\n              svg.selectAll('.rec').remove();\r\n            });\r\n          svg\r\n            .selectAll('.label')\r\n            .data(data)\r\n            .join('text')\r\n            .attr('class', 'label')\r\n            .attr('text-anchor', 'middle')\r\n            .attr('font-size', (node) => {\r\n              if (choice === 'sentiment') {\r\n                return scaleLS(Math.abs(node['sentiment'])) / 3;\r\n              } else return scaleL(node['amount']) / 3;\r\n            })\r\n            .attr('font-family', 'Open Sans')\r\n            .style('fill', 'black')\r\n            .attr('font-weight', '600')\r\n            .text((node) => {\r\n              return node['word'];\r\n            })\r\n            .attr('x', (node) => node.x)\r\n            .attr('y', (node) => node.y)\r\n            .on('mouseenter', (value) => {\r\n              mouseEnter(value);\r\n            });\r\n        });\r\n    };\r\n\r\n    simulationBubbles();\r\n  }, [\r\n    dimensions,\r\n    cleanEntries,\r\n    data,\r\n    maxValue,\r\n    minValue,\r\n    scoreValues,\r\n    dataChoice,\r\n    choice,\r\n    bubbles2Count,\r\n  ]);\r\n\r\n  const handleChange = (e) => {\r\n    e.preventDefault();\r\n    updateChoice(e.target.value);\r\n\r\n    dispatch(setChoice(e.target.value));\r\n\r\n    const id = e.target.id;\r\n    const el = document.getElementById(id);\r\n    el.classList.add('bubblechart__difficulty-select--selected');\r\n\r\n    if (id === 'compare-sentiment') {\r\n      document\r\n        .getElementById('keywords')\r\n        .classList.remove('bubblechart__difficulty-select--selected');\r\n    } else if (id === 'keywords') {\r\n      document\r\n        .getElementById('compare-sentiment')\r\n        .classList.remove('bubblechart__difficulty-select--selected');\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div ref={wrapperRef} className=\"bubblechart\">\r\n      <div className=\"bubblechart__select-menue\">\r\n        <button\r\n          className=\"bubblechart__difficulty-select bubblechart__difficulty-select--selected\"\r\n          value=\"keywords\"\r\n          id=\"keywords\"\r\n          onClick={(e) => handleChange(e)}\r\n        >\r\n          Keywords\r\n        </button>\r\n        <button\r\n          className=\"bubblechart__difficulty-select\"\r\n          value=\"sentiment\"\r\n          id=\"compare-sentiment\"\r\n          onClick={(e) => handleChange(e)}\r\n        >\r\n          Compare Sentiments\r\n        </button>\r\n      </div>\r\n      <svg ref={svgRef}></svg>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Bubblechart;\r\n","import { SET_CHOICE, AppActions } from './constants';\r\nimport { Choice } from '../components/types/Choice';\r\n\r\nexport const setChoice = (choice: Choice): AppActions => ({\r\n  type: SET_CHOICE,\r\n  choice,\r\n});\r\n","import React from 'react';\r\nimport { scaleLinear } from 'd3';\r\nimport { useSelector } from 'react-redux';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport { AppState } from '../reducers';\r\nimport { HighLowComment, Sentiment, SentimentCount } from './types/Comment';\r\n\r\ninterface HighestLowestAverage {\r\n  lowestComment: HighLowComment;\r\n  highestComment: HighLowComment;\r\n  sentiment: Sentiment;\r\n  sentimentCount: SentimentCount;\r\n}\r\n\r\nfunction HighestLowestAverage({\r\n  lowestComment,\r\n  highestComment,\r\n  sentiment,\r\n  sentimentCount,\r\n}: HighestLowestAverage) {\r\n  const highestCommentLikes = useSelector(\r\n    (state: AppState) => state.highestAndLowestCommentCount[0]\r\n  );\r\n\r\n  const lowestCommentLikes = useSelector(\r\n    (state: AppState) => state.highestAndLowestCommentCount[1]\r\n  );\r\n\r\n  const colorScale = scaleLinear<string>()\r\n    .domain([-2, 2])\r\n    .range(['rgb(238, 0, 0)', 'rgb(66, 230, 0)']);\r\n\r\n  const styleHighest = {\r\n    color: colorScale(highestComment[0]),\r\n  };\r\n\r\n  const styleLowest = {\r\n    color: colorScale(lowestComment[0]),\r\n  };\r\n\r\n  const average = {\r\n    color: colorScale(sentiment),\r\n  };\r\n  const generateSentimentField = () => {\r\n    const headings = [\r\n      'Highest Sentiment',\r\n      'Lowest Sentiment',\r\n      'Average Sentiment',\r\n    ];\r\n    let output = [];\r\n    for (let heading of headings) {\r\n      output.push(\r\n        <div className=\"card\" key={uuidv4()}>\r\n          <span className=\"card__heading\">\r\n            <h2 className=\"card__title\">{heading}</h2>\r\n            <div\r\n              className=\"card__sentiment\"\r\n              style={\r\n                heading === 'Lowest Sentiment'\r\n                  ? styleLowest\r\n                  : heading === 'Highest Sentiment'\r\n                  ? styleHighest\r\n                  : average\r\n              }\r\n            >\r\n              {heading === 'Highest Sentiment'\r\n                ? highestComment &&\r\n                  (highestComment[0] > 0 ? '+' : '') +\r\n                    highestComment[0].toString().slice(0, 5)\r\n                : heading === 'Lowest Sentiment'\r\n                ? lowestComment &&\r\n                  (lowestComment[0] > 0 ? '+' : '') +\r\n                    lowestComment[0].toString().slice(0, 5)\r\n                : (sentiment > 0 ? '+' : '') + sentiment.toString().slice(0, 4)}\r\n            </div>\r\n          </span>\r\n          {heading === 'Highest Sentiment' || heading === 'Lowest Sentiment' ? (\r\n            <div className=\"card__comment\">\r\n              {heading === 'Highest Sentiment'\r\n                ? `\"${highestComment[1]}\"`\r\n                : heading === 'Lowest Sentiment'\r\n                ? `\"${lowestComment[1]}\"`\r\n                : null}\r\n            </div>\r\n          ) : null}\r\n          {heading === 'Average Sentiment' ? (\r\n            <div className=\"card__average\">\r\n              <h6 className=\"card__average-sentiment\">\r\n                Negative Sentiments: {sentimentCount[0]}\r\n              </h6>\r\n              <h6 className=\"card__average-sentiment\">\r\n                Neutral Sentiments: {sentimentCount[1]}\r\n              </h6>\r\n              <h6 className=\"card__average-sentiment\">\r\n                Positive Sentiments: {sentimentCount[2]}\r\n              </h6>\r\n            </div>\r\n          ) : null}\r\n          {heading === 'Lowest Sentiment' ? (\r\n            <div className=\"card__comment-likes\">\r\n              Likes:\r\n              {lowestCommentLikes}\r\n            </div>\r\n          ) : heading === 'Highest Sentiment' ? (\r\n            <div className=\"card__comment-likes\">\r\n              Likes:\r\n              {highestCommentLikes}\r\n            </div>\r\n          ) : (\r\n            <div className=\"card__comment-likes\">\r\n              Comments: {sentimentCount.reduce((a, b) => a + b)}\r\n            </div>\r\n          )}\r\n        </div>\r\n      );\r\n    }\r\n    return output;\r\n  };\r\n  return <div className=\"comments\">{generateSentimentField()}</div>;\r\n}\r\n\r\nexport default HighestLowestAverage;\r\n","/**\r\n * Prefilter the comments into positive and negative comments\r\n * Makes the sorting easier later\r\n */\r\nimport { Comment } from '../types/Comment';\r\n\r\nexport const filterComments = (comments: Comment[]) => {\r\n  let positive = [];\r\n  let negative = [];\r\n  for (let comment of comments) {\r\n    if (comment[3] > 0) {\r\n      positive.push(comment);\r\n    } else if (comment[3] < 0) {\r\n      negative.push(comment);\r\n    }\r\n  }\r\n\r\n  positive = sortCommentsBySentiment(positive, '+');\r\n  negative = sortCommentsBySentiment(negative, '-');\r\n\r\n  return [positive, negative];\r\n};\r\n\r\n// Sort the comments by sentiment value\r\nconst sortCommentsBySentiment = (comments: Comment[], indicator: string) => {\r\n  let sorted: Comment[] = [];\r\n  let values: number[] = [];\r\n\r\n  // Give the comments ID's for later identification\r\n  let commentsCopy: Comment[] = comments.slice();\r\n  let index = 0;\r\n  for (let comment of commentsCopy) {\r\n    comment.push(index);\r\n    index++;\r\n  }\r\n\r\n  // Get all the sentiment-values\r\n  for (let comment of commentsCopy) {\r\n    values.push(comment[3]);\r\n  }\r\n\r\n  // Sort all the sentiment values\r\n  if (indicator === '+') {\r\n    values = values.sort((a, b) => a - b).reverse();\r\n  } else {\r\n    values = values.sort((a, b) => a - b);\r\n  }\r\n\r\n  /**\r\n   * Go through the values and find their belonging comment - if the\r\n   * index is already used, continue searching for the belonging value\r\n   */\r\n  const usedIndexes: number[] = [];\r\n  for (let value of values) {\r\n    for (let comment of commentsCopy) {\r\n      if (\r\n        comment[5] !== undefined &&\r\n        comment[3] === value &&\r\n        usedIndexes.indexOf(comment[5]) === -1\r\n      ) {\r\n        sorted.push(comment);\r\n        usedIndexes.push(comment[5]);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return sorted;\r\n};\r\n","import React, { useState, useEffect } from 'react';\r\nimport { useSelector } from 'react-redux';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport InfiniteScroll from 'react-infinite-scroller';\r\n//Helper\r\nimport { filterComments } from './helper/filterComments_helper';\r\nimport { AppState } from '../reducers';\r\nimport { Comment } from './types/Comment';\r\n\r\nfunction InfiniteScrollWindow() {\r\n  let comments = useSelector((state: AppState) => state.comments);\r\n  let [commentsFiltered, setCommentsFiltered] = useState<\r\n    Comment[][] | undefined\r\n  >();\r\n  let [positiveComments, setPositiveComments] = useState<\r\n    Comment[] | undefined\r\n  >();\r\n  let [negativeComments, setNegativeComments] = useState<\r\n    Comment[] | undefined\r\n  >();\r\n  const [hasmoreItems, setHasmoreItems] = useState(true);\r\n\r\n  /**\r\n   * Filters the comments when comments change\r\n   */\r\n  useEffect(() => {\r\n    setCommentsFiltered(filterComments(comments));\r\n  }, [comments]);\r\n\r\n  /**\r\n   * When filtered comments change update the positive and negative comments\r\n   */\r\n  useEffect(() => {\r\n    commentsFiltered && setPositiveComments(commentsFiltered[0].slice(0, 10));\r\n    commentsFiltered && setNegativeComments(commentsFiltered[1].slice(0, 10));\r\n  }, [commentsFiltered]);\r\n\r\n  const loadMorePositive = () => {\r\n    if (positiveComments !== undefined && commentsFiltered !== undefined) {\r\n      let count = positiveComments.length + 5;\r\n      if (count >= commentsFiltered[0].length) {\r\n        setHasmoreItems(false);\r\n        return;\r\n      }\r\n      setPositiveComments(commentsFiltered[0].slice(0, count));\r\n    }\r\n  };\r\n\r\n  const loadMoreNegative = () => {\r\n    if (negativeComments !== undefined && commentsFiltered !== undefined) {\r\n      let count = negativeComments.length + 5;\r\n      if (count >= commentsFiltered[1].length) {\r\n        setHasmoreItems(false);\r\n        return;\r\n      }\r\n      setNegativeComments(commentsFiltered[1].slice(0, count));\r\n    }\r\n  };\r\n\r\n  if (!positiveComments || !negativeComments) return null;\r\n\r\n  return (\r\n    <div className=\"infinite-wrapper\">\r\n      <div className=\"infinite-scroll\">\r\n        <h2 className=\"infinite-scroll__heading\">\r\n          Selected positive sentiments:\r\n        </h2>\r\n        <InfiniteScroll\r\n          className=\"infinite-scroll__wrapper\"\r\n          pageStart={0}\r\n          loadMore={loadMorePositive}\r\n          hasMore={hasmoreItems}\r\n          loader={\r\n            <div className=\"loader\" key={0}>\r\n              Loading ...\r\n            </div>\r\n          }\r\n          useWindow={false}\r\n        >\r\n          {positiveComments &&\r\n            positiveComments.map((comment) => {\r\n              return (\r\n                <div className=\"comment\" key={uuidv4()}>\r\n                  <div className=\"comment__text\">{`\"${comment[0]}\"`}</div>\r\n                  <div className=\"comment__sentiment\">\r\n                    {comment[3].toString().slice(0, 6)}\r\n                  </div>\r\n                </div>\r\n              );\r\n            })}\r\n        </InfiniteScroll>\r\n      </div>\r\n      <div className=\"infinite-scroll\">\r\n        <h2 className=\"infinite-scroll__heading\">\r\n          Selected negative sentiments:\r\n        </h2>\r\n        <InfiniteScroll\r\n          className=\"infinite-scroll__wrapper\"\r\n          pageStart={0}\r\n          loadMore={loadMoreNegative}\r\n          hasMore={hasmoreItems}\r\n          loader={\r\n            <div className=\"loader\" key={0}>\r\n              Loading ...\r\n            </div>\r\n          }\r\n          useWindow={false}\r\n        >\r\n          {negativeComments &&\r\n            negativeComments.map((comment) => {\r\n              return (\r\n                <div className=\"comment\" key={uuidv4()}>\r\n                  <div className=\"comment__text\">{`\"${comment[0]}\"`}</div>\r\n                  <div className=\"comment__sentiment\">\r\n                    {comment[3].toString().slice(0, 6)}\r\n                  </div>\r\n                </div>\r\n              );\r\n            })}\r\n        </InfiniteScroll>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default InfiniteScrollWindow;\r\n","import React from 'react';\r\nimport { useSelector } from 'react-redux';\r\nimport Bubblechart from './Bubblechart';\r\nimport HighestLowestAverage from './HighestLowestAverage';\r\nimport InfiniteScrollWindow from './InfiniteScrollWindow';\r\nimport { AppState } from '../reducers';\r\n\r\nfunction Display() {\r\n  const sentiment = useSelector((state: AppState) => state.sentiment.sentiment);\r\n  const sentimentCount = useSelector(\r\n    (state: AppState) => state.sentiment.sentimentCount\r\n  );\r\n  const highestComment = useSelector(\r\n    (state: AppState) => state.sentiment.highestComment\r\n  );\r\n  const lowestComment = useSelector(\r\n    (state: AppState) => state.sentiment.lowestComment\r\n  );\r\n  const videoTitle = useSelector((state: AppState) => state.videoTitle);\r\n  const keyCounts = useSelector((state: AppState) => state.keyCounts);\r\n  const singleWordSentiments = useSelector(\r\n    (state: AppState) => state.singleWordSentiments\r\n  );\r\n\r\n  if (!sentiment) return null;\r\n  return (\r\n    <div className=\"display\">\r\n      <h2 className=\"display__title-name\">{videoTitle}</h2>\r\n      <HighestLowestAverage\r\n        sentimentCount={sentimentCount}\r\n        lowestComment={lowestComment}\r\n        highestComment={highestComment}\r\n        sentiment={sentiment}\r\n      />\r\n      <InfiniteScrollWindow />\r\n      <Bubblechart data={keyCounts} dataSingleWords={singleWordSentiments} />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Display;\r\n","import React from 'react';\nimport Search from './components/Search';\nimport Display from './components/Display';\n\nfunction App() {\n  return (\n    <div className=\"app\">\n      <h1 className=\"app__page-title\">Consensus</h1>\n      <p className=\"app__subheading\">AFINN Youtube Sentiment Analysis</p>\n      <Search />\n      <Display />\n    </div>\n  );\n}\n\nexport default App;\n","import {\r\n  SET_SENTIMENT,\r\n  SET_SENTIMENT_COUNT,\r\n  SET_HIGHEST_COMMENT,\r\n  SET_LOWEST_COMMENT,\r\n  SET_COMMENT_COUNT,\r\n  SentimentActionTypes,\r\n} from '../actions/constants';\r\nimport { AverageSentiment } from '../components/types/Comment';\r\n\r\nconst initialState: AverageSentiment = {\r\n  sentiment: 0,\r\n  sentimentCount: [0, 0, 0],\r\n  highestComment: [NaN, ''],\r\n  lowestComment: [NaN, ''],\r\n  commentCount: 0,\r\n};\r\n\r\nexport const sentiment = (\r\n  state: AverageSentiment = initialState,\r\n  action: SentimentActionTypes\r\n): AverageSentiment => {\r\n  switch (action.type) {\r\n    case SET_SENTIMENT:\r\n      return {\r\n        ...state,\r\n        sentiment: action.sentiment,\r\n      };\r\n    case SET_SENTIMENT_COUNT:\r\n      return {\r\n        ...state,\r\n        sentimentCount: action.sentimentCount,\r\n      };\r\n    case SET_HIGHEST_COMMENT:\r\n      return {\r\n        ...state,\r\n        highestComment: action.highestComment,\r\n      };\r\n    case SET_LOWEST_COMMENT:\r\n      return {\r\n        ...state,\r\n        lowestComment: action.lowestComment,\r\n      };\r\n    case SET_COMMENT_COUNT:\r\n      return {\r\n        ...state,\r\n        commentCount: action.commentCount,\r\n      };\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n","import { SET_COMMENTS, CommentsActionTypes } from '../actions/constants';\r\nimport { Comment } from '../components/types/Comment';\r\n\r\nconst initialState: Comment[] = [];\r\n\r\nexport const comments = (\r\n  state = initialState,\r\n  action: CommentsActionTypes\r\n): Comment[] => {\r\n  switch (action.type) {\r\n    case SET_COMMENTS:\r\n      return action.comments;\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n","import {\r\n  SET_HIGHEST_SENTIMENT_SINGLE_WORDS,\r\n  SET_LOWEST_SENTIMENT_SINGLE_WORDS,\r\n  SingleWordSentimentsActionTypes,\r\n} from '../actions/constants';\r\nimport { SingleWordsSentiment } from '../components/types/SingleWord';\r\n\r\nconst initialState = {\r\n  highestSingleWords: {},\r\n  lowestSingleWords: {},\r\n};\r\n\r\nexport const singleWordSentiments = (\r\n  state: SingleWordsSentiment = initialState,\r\n  action: SingleWordSentimentsActionTypes\r\n): SingleWordsSentiment => {\r\n  switch (action.type) {\r\n    case SET_HIGHEST_SENTIMENT_SINGLE_WORDS:\r\n      return {\r\n        ...state,\r\n        highestSingleWords: action.highestSingleWords,\r\n      };\r\n    case SET_LOWEST_SENTIMENT_SINGLE_WORDS:\r\n      return {\r\n        ...state,\r\n        lowestSingleWords: action.lowestSingleWords,\r\n      };\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n","import { combineReducers } from 'redux';\r\nimport { videoTitle } from './videoTitle';\r\nimport { sentiment } from './sentiment';\r\nimport { keyCounts } from './keyCounts';\r\nimport { comments } from './comments';\r\nimport { highestAndLowestCommentCount } from './highestAndLowestCommentCount';\r\nimport { singleWordSentiments } from './singleWordSentiments';\r\nimport { choice } from './choice';\r\nimport { noCommentsModal } from './noCommentsModal';\r\n\r\nexport const rootReducer = combineReducers({\r\n  videoTitle,\r\n  sentiment,\r\n  keyCounts,\r\n  comments,\r\n  highestAndLowestCommentCount,\r\n  singleWordSentiments,\r\n  choice,\r\n  noCommentsModal,\r\n});\r\n\r\nexport type AppState = ReturnType<typeof rootReducer>;\r\n","import { SET_VIDEO_TITLE, VideoTitleActionTypes } from '../actions/constants';\r\n\r\nexport const videoTitle = (\r\n  state = '',\r\n  action: VideoTitleActionTypes\r\n): string => {\r\n  switch (action.type) {\r\n    case SET_VIDEO_TITLE:\r\n      return action.videoTitle;\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n","import { SET_KEYCOUNTS, KeyCountsActionTypes } from '../actions/constants';\r\nimport { KeyCounts } from '../components/types/KeyCounts';\r\n\r\nexport const keyCounts = (\r\n  state: KeyCounts = {},\r\n  action: KeyCountsActionTypes\r\n): KeyCounts => {\r\n  switch (action.type) {\r\n    case SET_KEYCOUNTS:\r\n      return action.keyCounts;\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n","import {\r\n  SET_HIGHEST_AND_LOWEST_COMMENT_COUNT,\r\n  CommentCountActionTypes,\r\n} from '../actions/constants';\r\nimport { HighLowCommentCount } from '../components/types/Comment';\r\n\r\nexport const highestAndLowestCommentCount = (\r\n  state: HighLowCommentCount = [0, 0],\r\n  action: CommentCountActionTypes\r\n): HighLowCommentCount => {\r\n  switch (action.type) {\r\n    case SET_HIGHEST_AND_LOWEST_COMMENT_COUNT:\r\n      return action.highLowCommentCount;\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n","import { SET_CHOICE, ChartChoiceActionTypes } from '../actions/constants';\r\nimport { Choice } from '../components/types/Choice';\r\n\r\nexport const choice = (\r\n  state: Choice = 'keywords',\r\n  action: ChartChoiceActionTypes\r\n): Choice => {\r\n  switch (action.type) {\r\n    case SET_CHOICE:\r\n      return action.choice;\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n","import {\r\n  TOGGLE_NO_COMMENTS_MODAL,\r\n  ModalActionTypes,\r\n} from '../actions/constants';\r\n\r\nexport const noCommentsModal = (\r\n  state: boolean = false,\r\n  action: ModalActionTypes\r\n): boolean => {\r\n  switch (action.type) {\r\n    case TOGGLE_NO_COMMENTS_MODAL:\r\n      return !state;\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n","import { createStore, applyMiddleware } from 'redux';\r\nimport { composeWithDevTools } from 'redux-devtools-extension';\r\nimport thunk, { ThunkMiddleware } from 'redux-thunk';\r\nimport { rootReducer, AppState } from '../reducers';\r\nimport { AppActions } from '../actions/constants';\r\n\r\nconst initialState = {};\r\n\r\nconst middleware = [thunk as ThunkMiddleware<AppState, AppActions>];\r\n\r\nconst store = createStore(\r\n  rootReducer,\r\n  initialState,\r\n  composeWithDevTools(applyMiddleware(...middleware))\r\n);\r\n\r\nexport default store;\r\n","import 'react-app-polyfill/ie9';\nimport 'react-app-polyfill/stable';\nimport 'core-js/stable';\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport store from './store';\nimport { Provider } from 'react-redux';\nimport './styles/main.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}