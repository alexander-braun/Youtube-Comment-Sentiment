{"version":3,"sources":["actions/setSentiments.js","actions/constants.js","actions/setKeycounts.js","actions/setVideoTitle.js","actions/setComments.js","components/Settings.js","actions/setSingleWordSentiments.js","actions/setHighestAndLowestCommentCount.js","components/Resizeobserver.js","components/Bubblechart.js","actions/setChoice.js","components/MaxComments.js","components/TitleStats.js","components/InfiniteScrollWindow.js","components/Display.js","App.js","serviceWorker.js","reducers/sentiment.js","reducers/singleWordSentiments.js","reducers/index.js","reducers/videoTitle.js","reducers/keyCounts.js","reducers/comments.js","reducers/highestAndLowestCommentCount.js","reducers/countries.js","reducers/choice.js","store/index.js","index.js"],"names":["setCommentCount","commentCount","type","setKeycounts","keyCounts","setVideoTitle","videoTitle","setComments","comments","Analyzer","require","SentimentAnalyzer","stemmer","PorterStemmer","keyword_extractor","apiKey","process","useStyles","makeStyles","theme","searchIcon","color","position","right","cursor","getKeywords","keywords","i","length","extraction","extract","language","remove_digits","return_changed_case","remove_duplicates","push","countKeywords","uniqueKeywords","keyword","word","toLowerCase","indexOf","keyCount","findLikesForHighestAndLowestComment","highest","lowest","highestCommentLikes","lowestCommentLikes","comment","overallSentiment","analyzer","sentiments","parseFloat","sentimentCount","lowWords","highWords","tokenized","split","sentiSingle","j","obj","getSentiment","sentiment","isNaN","cleanComments","cleanedComments","getVideoTitle","ID","a","undefined","url","fetch","response","json","data","title","Settings","useState","videoLink","updateVideoLink","videoID","updateVideoID","dispatch","useDispatch","useEffect","link","equalSignIndex","search","slice","shortenToVideoID","calc","e","preventDefault","getComments","flat","sentimentCollector","highestComment","lowestComment","lowestSingleWords","highestSingleWords","highestLowest","highLowCommentCount","fetchComments","textArr","token","maxSearchLength","nextPageToken","text","map","splitcomment","classes","className","placeholder","id","name","onChange","target","value","onClick","useResizeObserver","ref","dimensions","setDimensions","observeTarget","current","resizeObserver","ResizeObserver","entries","forEach","entry","contentRect","observe","unobserve","Bubblechart","dataSingleWords","svgRef","useRef","wrapperRef","Object","useSelector","state","scoreValues","newEntries","Number","sort","b","scoreCount","window","innerWidth","filter","arr","heighestXEntries","cleanEntries","sentimentWordsCombined","category","keys","bubbles2Count","width","count","key","minValue","maxValue","choice","updateChoice","dataChoice","useCallback","minMaxNumbers","d3","svg","select","mouseEnter","selectAll","join","enter","append","attr","node","element","height","style","colorScale","colorScaleS","Math","abs","x","scaleOrdinal","domain","Set","range","scaleLinear","scaleBubbles","scaleL","scaleLS","xCenter","forceSimulation","force","forceManyBody","strength","d","forceCenter","forceCollide","radius","on","remove","y","handleChange","setChoice","document","getElementById","classList","add","MaxComments","styleHighest","styleLowest","average","highestAndLowestCommentCount","output","heading","uuidv4","toString","reduce","generateSentimentField","TitleStats","indicator","sorted","values","reverse","InfiniteScrollWindow","commentsFiltered","setCommentsFiltered","positiveComments","setPositiveComments","negativeComments","setNegativeComments","positive","negative","filterComments","hasmoreItems","setHasmoreItems","pageStart","loadMore","hasMore","loader","useWindow","getScrollParent","getElementsByClassName","Display","singleWordSentiments","App","Boolean","location","hostname","match","initialState","combineReducers","action","countries","middleware","thunk","store","createStore","rootReducer","composeWithDevTools","applyMiddleware","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.61fab861.chunk.js","sourcesContent":["import { \r\n    SET_SENTIMENT, \r\n    SET_SENTIMENT_COUNT, \r\n    SET_HIGHEST_COMMENT, \r\n    SET_LOWEST_COMMENT,\r\n    SET_COMMENT_COUNT\r\n} from './constants'\r\n\r\nexport const setSentiment = sentiment => ({\r\n    type: SET_SENTIMENT,\r\n    sentiment\r\n})\r\n\r\nexport const setSentimentCount = sentimentCount => ({\r\n    type: SET_SENTIMENT_COUNT,\r\n    sentimentCount\r\n})\r\n\r\nexport const setHighestComment = highestComment => ({\r\n    type: SET_HIGHEST_COMMENT,\r\n    highestComment\r\n})\r\n\r\nexport const setLowestComment = lowestComment => ({\r\n    type: SET_LOWEST_COMMENT,\r\n    lowestComment\r\n})\r\n\r\nexport const setCommentCount = commentCount => ({\r\n    type: SET_COMMENT_COUNT,\r\n    commentCount\r\n})","export const SET_VIDEO_TITLE = 'SET_VIDEO_TITLE'\r\nexport const SET_SENTIMENT = 'SET_SENTIMENT'\r\nexport const SET_SENTIMENT_COUNT = 'SET_SENTIMENT_COUNT'\r\nexport const SET_HIGHEST_COMMENT = 'SET_HIGHEST_COMMENT'\r\nexport const SET_LOWEST_COMMENT = 'SET_LOWEST_COMMENT'\r\nexport const SET_KEYCOUNTS = 'SET_KEYCOUNTS'\r\nexport const SET_COMMENT_COUNT = 'SET_COMMENT_COUNT'\r\nexport const SET_COMMENTS = 'SET_COMMENTS'\r\nexport const SET_HIGHEST_AND_LOWEST_COMMENT_COUNT = 'SET_HIGHEST_AND_LOWEST_COMMENT_COUNT'\r\nexport const SET_HIGHEST_SENTIMENT_SINGLE_WORDS = 'SET_HIGHEST_SENTIMENT_SINGLE_WORD'\r\nexport const SET_LOWEST_SENTIMENT_SINGLE_WORDS = 'SET_LOWEST_SENTIMENT_SINGLE_WORD'\r\nexport const SET_COUNTRIES = 'SET_COUNTRIES'\r\nexport const SET_CHOICE = 'SET_CHOICE'","import { SET_KEYCOUNTS } from './constants'\r\n\r\nexport const setKeycounts = keyCounts => ({\r\n    type: SET_KEYCOUNTS,\r\n    keyCounts\r\n})","import { SET_VIDEO_TITLE } from './constants'\r\n\r\nexport const setVideoTitle = videoTitle => ({\r\n    type: SET_VIDEO_TITLE,\r\n    videoTitle\r\n})","import { SET_COMMENTS } from './constants'\r\n\r\nexport const setComments = comments => ({\r\n    type: SET_COMMENTS,\r\n    comments\r\n})","import React, { useState, useEffect } from 'react'\r\nimport { useDispatch, useSelector } from 'react-redux'\r\nimport '../styles/settings.css'\r\n\r\nimport SearchIcon from '@material-ui/icons/Search'\r\nimport { makeStyles } from '@material-ui/core/styles'\r\n\r\nimport { \r\n    setSentiment, \r\n    setSentimentCount, \r\n    setHighestComment, \r\n    setLowestComment, \r\n    setCommentCount\r\n} from '../actions/setSentiments'\r\n\r\nimport { setKeycounts } from '../actions/setKeycounts'\r\nimport { setVideoTitle } from '../actions/setVideoTitle'\r\nimport { setComments } from '../actions/setComments'\r\nimport { setHighestAndLowestCommentCount } from '../actions/setHighestAndLowestCommentCount'\r\nimport { setHighestSingleWords, setLowestSingleWords } from '../actions/setSingleWordSentiments'\r\nimport { setCountries } from '../actions/setCountries'\r\n\r\nvar Analyzer = require('natural').SentimentAnalyzer\r\nvar stemmer = require('natural').PorterStemmer\r\nvar keyword_extractor = require(\"keyword-extractor\")\r\nlet apiKey = process.env.REACT_APP_API_KEY\r\n\r\nconst useStyles = makeStyles((theme) => ({\r\n    searchIcon: {\r\n      color: 'rgba(128, 128, 128, 0.5)',\r\n      position: 'absolute',\r\n      right: '10px',\r\n      cursor: 'pointer'\r\n    },\r\n}))\r\n\r\nconst getKeywords = (comments) => {\r\n    let keywords = []\r\n\r\n    for(let i = 0; i < comments.length; i++) {\r\n        let extraction = keyword_extractor.extract(comments[i], {\r\n            language:\"english\",\r\n            remove_digits: true,\r\n            return_changed_case:true,\r\n            remove_duplicates: false\r\n        })\r\n        keywords.push(extraction)\r\n    }\r\n    return keywords\r\n}\r\n\r\nconst countKeywords = (keywords) => {\r\n\r\n    // Get all the unique keywords\r\n    let uniqueKeywords = []\r\n    for(let i = 0; i < keywords.length; i++) {\r\n        for(let keyword of keywords[i]) {\r\n            if(keyword) {\r\n                let word = keyword.toLowerCase()    \r\n                uniqueKeywords.indexOf(word) === -1 && uniqueKeywords.push(word)\r\n            }\r\n        }\r\n    }\r\n\r\n    // Put all of them into an object an count them\r\n    let keyCount = {}\r\n    for(let i = 0; i < keywords.length; i++) {\r\n        for(let keyword of keywords[i]) {\r\n            keyCount[keyword] && keyCount[keyword]++\r\n            !keyCount[keyword] && (keyCount[keyword] = 1)\r\n        }\r\n    }\r\n\r\n    return keyCount\r\n}\r\n\r\nconst findLikesForHighestAndLowestComment = (highest, lowest, comments) => {\r\n    let highestCommentLikes = 0\r\n    let lowestCommentLikes = 0\r\n    for(let comment of comments) {\r\n        if(comment[0] === highest[1]) {\r\n            highestCommentLikes = comment[1]\r\n        }\r\n        if(comment[0] === lowest[1]) {\r\n            lowestCommentLikes = comment[1]\r\n        }\r\n    }\r\n    return [highestCommentLikes, lowestCommentLikes]\r\n}\r\n\r\nconst overallSentiment = (comments) => {\r\n\r\n    let analyzer = new Analyzer(\"English\", stemmer, \"afinn\")\r\n    let length = comments.length\r\n    let sentiments = parseFloat(0)\r\n\r\n    // Counts POS and NEG comments POS/NEG\r\n    let sentimentCount = [0, 0, 0]\r\n\r\n    // Set highest and lowest commentscore\r\n    let highest = [-10, null]\r\n    let lowest = [10, null]\r\n\r\n    // Set highest and lowest score for individual words\r\n    let lowWords = []\r\n    let highWords = []\r\n\r\n    for(let i = 0; i < length; i++) {\r\n\r\n        // Get sentiment number\r\n        let tokenized = comments[i].split(' ')\r\n\r\n        // Get the single word sentiments\r\n        let sentiSingle\r\n        for(let j = 0; j < tokenized.length; j++) {\r\n            sentiSingle = parseFloat(analyzer.getSentiment([tokenized[j]]))\r\n            let obj = {}\r\n            if(sentiSingle <= -1) {\r\n                obj['word'] = tokenized[j]\r\n                obj['sentiment'] = sentiSingle\r\n                lowWords.push(obj)\r\n            } else if(sentiSingle >= 1) {\r\n                obj['word'] = tokenized[j]\r\n                obj['sentiment'] = sentiSingle\r\n                highWords.push(obj)\r\n            }\r\n        }\r\n        // Get the whole comments sentiment from here on\r\n        const sentiment = parseFloat(analyzer.getSentiment(tokenized))\r\n\r\n        // Add POS or NEG or NEUTRAL\r\n        sentiment > 0 && sentimentCount[2]++\r\n        sentiment === 0 && sentimentCount[1]++\r\n        sentiment < 0 && sentimentCount[0]++\r\n        \r\n        sentiment > highest[0] && (highest[0] = sentiment) && (highest[1] = comments[i])\r\n        sentiment < lowest[0] && (lowest[0] = sentiment) && (lowest[1] = comments[i])\r\n\r\n        // Sometimes NaN is returned so this prevents it from beeing added to the overall score\r\n        if(!isNaN(sentiment)) {\r\n            sentiments += sentiment\r\n        }\r\n    }\r\n    return [sentiments / length, sentimentCount, highest, lowest, lowWords, highWords]\r\n}\r\n\r\n// Takes the video link and returns the ID\r\nconst shortenToVideoID = (link) => {\r\n    const equalSignIndex = link.search('=')\r\n    const videoID = link.slice(equalSignIndex + 1)\r\n    return videoID\r\n}\r\n\r\n\r\nconst cleanComments = (comments) => {\r\n    let cleanedComments = []\r\n    for(let i = 0; i < comments.length; i++) {\r\n        cleanedComments.push(comments[i][0])\r\n    }\r\n    return cleanedComments\r\n}\r\n\r\nconst getVideoTitle = async (ID) => {\r\n    if(ID && ID !== undefined) {\r\n        let url = `https://noembed.com/embed?url=https%3A%2F%2Fhttps://www.youtube.com/watch?v=${ID}`\r\n        const response = await fetch(url)   \r\n        const data = await response.json()\r\n        const title = await data['title']\r\n        return title\r\n    }\r\n\r\n    return null\r\n}\r\n\r\nfunction Settings() {\r\n\r\n    const [videoLink, updateVideoLink] = useState('')\r\n    const [videoID, updateVideoID] = useState()\r\n\r\n    const dispatch = useDispatch()\r\n\r\n    useEffect(() => {\r\n        // Get and Update Video ID\r\n        const ID = shortenToVideoID(videoLink)\r\n        updateVideoID(ID)\r\n    }, [videoLink])\r\n\r\n    // Main knot to get all needed information from the api\r\n    const calc = async (e) => {\r\n        e.preventDefault()\r\n\r\n        // Get Video Title\r\n        let videoTitle = await getVideoTitle(videoID)\r\n\r\n        dispatch(setVideoTitle(videoTitle))\r\n\r\n        // Get last 100 comments\r\n        let comments = await getComments()\r\n        if(comments.length === 0) return\r\n        comments = comments.flat()\r\n        dispatch(setComments(comments))\r\n\r\n        // Extract comments from [comment, likes, id]\r\n        let cleanedComments = cleanComments(comments)\r\n        let commentCount = cleanedComments.length\r\n        dispatch(setCommentCount(commentCount))\r\n\r\n        // Calculate the sentiment and update\r\n        let sentimentCollector = overallSentiment(cleanedComments)\r\n        \r\n        dispatch(setSentiment(sentimentCollector[0]))\r\n        dispatch(setSentimentCount(sentimentCollector[1]))\r\n        dispatch(setHighestComment(sentimentCollector[2]))\r\n        dispatch(setLowestComment(sentimentCollector[3]))\r\n        dispatch(setLowestSingleWords(sentimentCollector[4]))\r\n        dispatch(setHighestSingleWords(sentimentCollector[5]))\r\n        \r\n        // Get and set the likes for the highest and lowest sentiment comments\r\n        let highestLowest = findLikesForHighestAndLowestComment(sentimentCollector[2], sentimentCollector[3], comments)\r\n        dispatch(setHighestAndLowestCommentCount(highestLowest))\r\n\r\n        // Get all the keywords from all the comments and count them\r\n        let keywords = getKeywords(cleanedComments)\r\n        let keyCounts = countKeywords(keywords)\r\n        dispatch(setKeycounts(keyCounts))\r\n    }\r\n\r\n    const getComments = () => {\r\n        let ID = videoID\r\n        let maxResults = 100\r\n        let maxSearchLength = 10\r\n        let analyzer = new Analyzer(\"English\", stemmer, \"afinn\")\r\n        \r\n        async function fetchComments(textArr = [], token) {\r\n\r\n            // If there are X comments already in array return array\r\n            if(textArr.length >= maxSearchLength / 100) {\r\n                return textArr\r\n            }\r\n\r\n            // Change the url based on if there is a new nextPageToken or not\r\n            let url\r\n            if(token) {\r\n                url = `https://www.googleapis.com/youtube/v3/commentThreads?key=${apiKey}&textFormat=plainText&part=snippet&videoId=${ID}&maxResults=${maxResults}&pageToken=${token}`\r\n            } else {\r\n                url = `https://www.googleapis.com/youtube/v3/commentThreads?key=${apiKey}&textFormat=plainText&part=snippet&videoId=${ID}&maxResults=${maxResults}`\r\n            }\r\n\r\n            // Grab the data and get comment and likecount for comment\r\n            const response = await fetch(url)    \r\n            const data = await response.json()\r\n            const nextPageToken = await data['nextPageToken']\r\n            let text = await data['items']\r\n\r\n\r\n            // If the address was f.e. empty and there are no results just return []\r\n            if(!text) return []\r\n\r\n            // Else put the text and the likecount (not used yet) into an array\r\n            text = text.map(comment => {\r\n                const splitcomment = comment['snippet']['topLevelComment']['snippet']['textDisplay'].split(' ')\r\n                return [\r\n                    comment['snippet']['topLevelComment']['snippet']['textDisplay'],\r\n                    comment['snippet']['topLevelComment']['snippet']['likeCount'],\r\n                    comment['snippet']['topLevelComment']['snippet']['authorChannelId']['value'],\r\n                    analyzer.getSentiment(splitcomment),\r\n                    comment['snippet']['topLevelComment']['snippet']['authorChannelUrl']\r\n                ]\r\n            })\r\n\r\n            // Push data to array that is passed along\r\n            textArr.push(text)\r\n\r\n            // If there is one more comment page to load grab the nextpagetoken for that site\r\n            // Not used as it eats the free api usage too quickly. Could grab all other comments\r\n            // If used\r\n            if(nextPageToken) {\r\n                return fetchComments(textArr, nextPageToken)\r\n            }\r\n\r\n            // Or else just return the array\r\n            else if(!nextPageToken) return textArr\r\n        }\r\n\r\n        \r\n        return fetchComments([], null)\r\n    }\r\n\r\n    const classes = useStyles()\r\n\r\n    return (\r\n        <div className=\"settings\">\r\n            <form>\r\n                <input placeholder=\"Enter Youtube Video Link...\" type=\"text\" id=\"video-link\" name=\"video-link\" onChange={e => updateVideoLink(e.target.value)} value={videoLink} />\r\n                <SearchIcon className={classes.searchIcon} onClick={calc}/>\r\n            </form> \r\n            <button onClick={calc} value=\"Search\">Search</button>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Settings\r\n","import { SET_HIGHEST_SENTIMENT_SINGLE_WORDS, SET_LOWEST_SENTIMENT_SINGLE_WORDS } from './constants'\r\n\r\nexport const setHighestSingleWords = highestSingleWords => ({\r\n    type: SET_HIGHEST_SENTIMENT_SINGLE_WORDS,\r\n    highestSingleWords\r\n})\r\n\r\nexport const setLowestSingleWords = lowestSingleWords => ({\r\n    type: SET_LOWEST_SENTIMENT_SINGLE_WORDS,\r\n    lowestSingleWords\r\n})","import { SET_HIGHEST_AND_LOWEST_COMMENT_COUNT } from './constants'\r\n\r\nexport const setHighestAndLowestCommentCount = highLowCommentCount => ({\r\n    type: SET_HIGHEST_AND_LOWEST_COMMENT_COUNT,\r\n    highLowCommentCount\r\n})","import ResizeObserver from \"resize-observer-polyfill\";\r\nimport { useEffect, useState } from \"react\";\r\n\r\nconst useResizeObserver = ref => {\r\n    const [dimensions, setDimensions] = useState(null);\r\n    useEffect(() => {\r\n      const observeTarget = ref.current;\r\n      const resizeObserver = new ResizeObserver(entries => {\r\n        entries.forEach(entry => {\r\n          setDimensions(entry.contentRect);\r\n        });\r\n      });\r\n      resizeObserver.observe(observeTarget);\r\n      return () => {\r\n        resizeObserver.unobserve(observeTarget);\r\n      };\r\n    }, [ref]);\r\n    return dimensions;\r\n};\r\n\r\nexport default useResizeObserver","import * as d3 from 'd3'\r\nimport { \r\n    select, \r\n    forceSimulation, \r\n    scaleOrdinal, \r\n    forceCollide, \r\n    forceManyBody, \r\n    forceCenter,\r\n    scaleLinear,\r\n    geoPath,\r\n    geoMercator } from \"d3\"\r\nimport React, { useRef, useEffect, useState, useCallback } from \"react\"\r\nimport useResizeObserver from './Resizeobserver'\r\nimport geodata from './custom.geo.json'\r\nimport { useSelector, useDispatch } from 'react-redux'\r\nimport { setChoice } from '../actions/setChoice'\r\nimport { setCountries } from '../actions/setCountries'\r\nlet apiKey = process.env.REACT_APP_API_KEY\r\n\r\nfunction Bubblechart({ data, dataSingleWords }) {\r\n    const svgRef = useRef()\r\n    const wrapperRef = useRef()\r\n    const dimensions = useResizeObserver(wrapperRef)\r\n    const entries = Object.entries(data)\r\n    const alphabet = 'abcdefghijklmnopqrstuvwxyz1234567890'\r\n    const comments = useSelector(state => state.comments)\r\n    const dispatch = useDispatch()\r\n\r\n    let scoreValues = []\r\n    const heighestXEntries = () => {\r\n\r\n        // Get all unique counts for a word and sort them\r\n        for(let entry of entries) {\r\n            if(scoreValues.indexOf(entry[1]) === -1) scoreValues.push(Number(entry[1]))\r\n        }\r\n        scoreValues.sort((a, b) => a - b)\r\n\r\n        // ScoreCount is the max number of bubbles for the bubblediagram\r\n        let scoreCount = 25\r\n        if(window.innerWidth < 700) scoreCount = 15\r\n\r\n        // goes backwards through the scores and pushes [word, count] into newEntries\r\n        let newEntries = []\r\n        for(let i = scoreValues.length; i > 0; i--) {\r\n            newEntries.push(...entries.filter(arr => {\r\n                return arr[1] === scoreValues[i] && arr\r\n            }))\r\n            if(newEntries.length >= scoreCount) break\r\n        }\r\n        return newEntries.slice(0, scoreCount)\r\n    }\r\n\r\n    let newEntries = heighestXEntries()\r\n\r\n    // Sorts the entries as object (for d3) into an array. Gets rid of single character mentions like = or -\r\n    let cleanEntries = []\r\n    for(let entry of newEntries) {\r\n        if(entry[1] > 1) {\r\n            if(alphabet.indexOf(entry[0][0]) === -1){\r\n                continue\r\n            }\r\n            let obj = {'word': null, 'amount': null}\r\n            obj['word'] = entry[0]\r\n            obj['amount'] = entry[1]\r\n            cleanEntries.push(obj)\r\n        }\r\n    }\r\n\r\n    // Merge Singlewordsentiments and assign category 0 or 1\r\n    let sentimentWordsCombined = []\r\n    let category = 0\r\n    let keys = Object.keys(dataSingleWords)\r\n\r\n    let bubbles2Count = 15\r\n    if(dimensions && dimensions.width <= 700) bubbles2Count = 10\r\n\r\n    let count = 0\r\n\r\n    for(let key of keys) {\r\n        for(let i = 0; i < dataSingleWords[key].length; i++) {\r\n            if(count < bubbles2Count) {\r\n                let obj = dataSingleWords[key][i]\r\n                obj['category'] = category\r\n                sentimentWordsCombined.push(obj)    \r\n                count++\r\n            }\r\n        }\r\n        count = 0\r\n        category++\r\n    }\r\n\r\n    // Base bubbles on choice of keywords or sentiment words\r\n    const [choice, updateChoice] = useState('keywords')\r\n    const dataChoice = useCallback(() => {\r\n        return choice === 'keywords' ? cleanEntries : sentimentWordsCombined\r\n    }, [choice, cleanEntries, sentimentWordsCombined])\r\n\r\n    // Gets the minValue and maxValue of word counts\r\n    let minValue\r\n    let maxValue\r\n\r\n    if(dataChoice().length !== 0) {\r\n        let minMaxNumbers = []\r\n        for(let entry of dataChoice()) {\r\n            minMaxNumbers.push(entry['amount' || 'sentiment'])\r\n        }\r\n        minValue = d3.min(minMaxNumbers)\r\n        maxValue = d3.max(minMaxNumbers)\r\n    }\r\n\r\n    useEffect(() => {\r\n\r\n        let data = dataChoice()\r\n        if(!dimensions) return\r\n        let svg = null\r\n        svg = select(svgRef.current)\r\n\r\n        const mouseEnter = (value) => {\r\n            svg\r\n                .selectAll('.rec')\r\n                .data(() => {\r\n                    if(choice === 'sentiment') {\r\n                        return [[value['sentiment'], value['word']]]\r\n                    } else return [[value['amount'], value['word']]]\r\n                })\r\n                .join(enter => enter.append(\"rect\"))\r\n                .attr(\"class\", \"rec\")\r\n                .attr(\"x\", (node) => {\r\n                    for(let element of cleanEntries) {\r\n                        if(choice !== 'sentiment') {\r\n                            if(element['word'] === node[1]){\r\n                                if(dimensions.width <= 700) {\r\n                                    return dimensions.width / 2 - 175\r\n                                }else return element['x'] + 100\r\n                            }   \r\n                        } else return dimensions.width / 2 - (node[1].length * 4 + 150)\r\n                    }\r\n                })\r\n                .attr('width', node => {\r\n                    return `${node[1].length * 4 + 300}px`\r\n                })\r\n                .attr('height', '40px')\r\n                .attr(\"text-anchor\", \"middle\")\r\n                .attr(\"y\", (node) => {\r\n                    for(let element of cleanEntries) {\r\n                        if(choice !== 'sentiment') {\r\n                            if(element['word'] === node[1]){\r\n                                return element['y']\r\n                            }     \r\n                        } else return dimensions.height / 2\r\n                    }\r\n                })\r\n                .attr(\"opacity\", 1)\r\n                .attr('fill', 'white')\r\n                .style('stroke', node => {\r\n                    if(choice !== 'sentiment') {\r\n                        return colorScale(node[0])\r\n                    } else {\r\n                        return colorScaleS(Math.abs(node[0]))\r\n                    }\r\n                })\r\n                .style('stroke-width', 2)\r\n                .attr(\"rx\", 4)\r\n            svg\r\n                .selectAll(\".tooltip\")\r\n                .data(() => {\r\n                    if(choice === 'sentiment') {\r\n                        return [[value['sentiment'], value['word']]]\r\n                    } else return [[value['amount'], value['word']]]\r\n                })\r\n                .join(enter => enter.append(\"text\"))\r\n                .attr(\"class\", \"tooltip\")\r\n                .text(node => {\r\n                    if(choice === 'sentiment') {\r\n                        return `sentiment: ${node[0]}, word: \"${node[1]}\"`\r\n                    }else return `${node[0]} times used: \"${node[1]}\"`\r\n                })\r\n                .attr(\"x\", (node) => {\r\n                    let x = dimensions.width / 2\r\n                    for(let element of cleanEntries) {\r\n                        if(element['word'] === node[1]){\r\n                            if(choice !== 'sentiment') {\r\n                                if(dimensions.width <= 700) {\r\n                                    x = dimensions.width / 2\r\n                                } else x = element['x'] + node[1].length * 4 + 200    \r\n                            } else x = dimensions.width / 2\r\n                        } \r\n                    }\r\n                    return x\r\n                })\r\n                .attr(\"text-anchor\", \"middle\")\r\n                .attr(\"y\", (node) => {\r\n                    for(let element of cleanEntries) {\r\n                        if(choice !== 'sentiment') {\r\n                            if(element['word'] === node[1]){\r\n                                return element['y'] + 25\r\n                            } \r\n                        } else return dimensions.height / 2 + 25\r\n                    }\r\n                })\r\n                .attr(\"opacity\", 1)\r\n                .attr('fill', 'black')\r\n        }\r\n        // Colors for Bubbles\r\n        const colorScale = scaleOrdinal()\r\n            .domain(new Set(scoreValues))\r\n            .range([\"#00e8e8\", \"#F2CB05\", \"#F28705\", \"#D92818\", \"#D94141\", \"#0ba3ff\", \"#6aafda\"])\r\n\r\n        const colorScaleS = scaleLinear()\r\n            .domain([0, 5])\r\n            .range(['rgb(217, 29, 0)', 'rgb(66, 230, 0)'])\r\n\r\n        // Determines the scale based on screen size\r\n        let scaleBubbles = 1.3\r\n        if(dimensions.width <= 700) scaleBubbles = 1\r\n\r\n        // Scale for bubbles using scale var\r\n        const scaleL = d3.scaleSqrt()\r\n            .domain([minValue, maxValue])\r\n            .range([25 * scaleBubbles, 60 * scaleBubbles])\r\n        \r\n        let scaleBubblesS = 2\r\n\r\n        const scaleLS = d3.scaleSqrt()\r\n            .domain([0, 5])\r\n            .range([0 * scaleBubblesS, 25 * scaleBubblesS])\r\n        svg\r\n            .style(\"width\", '100%')\r\n            .style(\"height\", '100%')\r\n\r\n        svg.attr('viewbox', `0 0 ${dimensions.width} ${dimensions.height}`)\r\n\r\n        const xCenter = [dimensions.width / 4, dimensions.width - dimensions.width / 4]\r\n\r\n        const simulationBubbles = () => {\r\n            if(choice === 'countries') return\r\n            forceSimulation(data)\r\n                .force(\"charge\", forceManyBody().strength(20))\r\n                .force('x', choice === 'sentiment' ? d3.forceX().x(d => {\r\n                    if(choice === 'sentiment') {\r\n                        return d['category'] === 0 ? xCenter[0] : xCenter[1]    \r\n                    }}) : null \r\n                )\r\n                .force('center', forceCenter(dimensions.width / 2, dimensions.height  / 2))\r\n                .force(\"collide\", forceCollide().radius(node => {\r\n                    if(choice === 'sentiment') {\r\n                        return scaleLS(Math.abs(Number(node['sentiment'])))\r\n                    } else return scaleL(node['amount'])\r\n                }))\r\n                .on('tick', () => {\r\n                    svg \r\n                        .selectAll('.country').remove()\r\n                        .selectAll('.label2').remove()\r\n                    svg\r\n                        .selectAll('.node')\r\n                        .data(data)\r\n                        .join('circle')\r\n                        .attr('class', 'node')\r\n                        .attr('r', node => {\r\n                            if(choice === 'sentiment') {\r\n                                return scaleLS(Math.abs(Number(node['sentiment'])))\r\n                            } else return scaleL(node['amount'])\r\n                        })\r\n                        .style('fill', node => {\r\n                            if(choice === 'sentiment') {\r\n                                return colorScaleS(node['sentiment'])\r\n                            }else return colorScale(node['amount'])\r\n                        })\r\n                        .attr('cx', node => node.x)\r\n                        .attr('cy', node => node.y)\r\n                        .on(\"mouseenter\", (value) => {\r\n                            mouseEnter(value)\r\n                        })\r\n                        .on(\"mouseleave\", () => {\r\n                            svg.selectAll(\".tooltip\").remove()\r\n                            svg.selectAll('.rec').remove()\r\n                        })\r\n                    svg\r\n                        .selectAll('.label')\r\n                        .data(data)\r\n                        .join('text')\r\n                        .attr('class', 'label')\r\n                        .attr('text-anchor', 'middle')\r\n                        .attr('font-size', node => {\r\n                            if(choice === 'sentiment') {\r\n                                return scaleLS(Math.abs(node['sentiment'])) / 3\r\n                            } else return scaleL(node['amount']) / 3\r\n                        })\r\n                        .attr('font-family', 'Open Sans')\r\n                        .style('fill', 'black')\r\n                        .attr('font-weight', '600')\r\n                        .text(node => {\r\n                            return node['word']\r\n                        })\r\n                        .attr('x', node => node.x)\r\n                        .attr('y', node => node.y)\r\n                        .on(\"mouseenter\", (value) => {\r\n                            mouseEnter(value)\r\n                        })\r\n\r\n            })\r\n        }\r\n\r\n        simulationBubbles()\r\n\r\n    }, [dimensions, cleanEntries, data, maxValue, minValue, scoreValues, dataChoice, choice, bubbles2Count])\r\n\r\n\r\n    const handleChange = (e) => {\r\n        e.preventDefault()\r\n        updateChoice(e.target.value)\r\n\r\n        dispatch(setChoice(e.target.value))\r\n\r\n        const id = e.target.id\r\n        const el = document.getElementById(id)\r\n        el.classList.add('selected')\r\n\r\n        if(id === 'countries') {\r\n            document.getElementById('keywords').classList.remove('selected')\r\n            document.getElementById('compare-sentiment').classList.remove('selected')\r\n        } else if(id === 'compare-sentiment') {\r\n            document.getElementById('keywords').classList.remove('selected')\r\n            //document.getElementById('countries').classList.remove('selected')\r\n        } else if(id === 'keywords') {\r\n            //document.getElementById('countries').classList.remove('selected')\r\n            document.getElementById('compare-sentiment').classList.remove('selected')\r\n        }\r\n    }\r\n\r\n    return (\r\n        <div ref={wrapperRef} className=\"bubblechart\">\r\n            <div className=\"select-menue\">\r\n                <button className=\"difficulty_select selected\" value=\"keywords\" id=\"keywords\" onClick={e=> handleChange(e)}>Keywords</button>\r\n                <button className=\"difficulty_select\" value=\"sentiment\" id=\"compare-sentiment\" onClick={e=> handleChange(e)}>Compare Sentiments</button>\r\n                {/* <button className=\"difficulty_select\" value=\"countries\" id=\"countries\" onClick={e=> handleChange(e)}>Per Country</button> */}\r\n            </div>\r\n            <svg ref={svgRef}>\r\n\r\n            </svg>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Bubblechart","import { SET_CHOICE } from './constants'\r\n\r\nexport const setChoice = choice => ({\r\n    type: SET_CHOICE,\r\n    choice\r\n})","import React from 'react'\r\nimport { scaleLinear } from \"d3\"\r\nimport { useSelector } from 'react-redux'\r\nimport { v4 as uuidv4 } from 'uuid';\r\n\r\nfunction MaxComments({ lowestComment, highestComment, sentiment, sentimentCount }) {\r\n\r\n    const colorScale = scaleLinear()\r\n        .domain([-2, 2])\r\n        .range(['rgb(238, 0, 0)', 'rgb(66, 230, 0)'])\r\n\r\n    const styleHighest = {\r\n        color: colorScale(highestComment[0])\r\n    }\r\n\r\n    const styleLowest = {\r\n        color: colorScale(lowestComment[0])\r\n    }\r\n\r\n    const average = {\r\n        color: colorScale(sentiment)\r\n    }\r\n\r\n    const highestCommentLikes = useSelector(state => state.highestAndLowestCommentCount[0])\r\n    const lowestCommentLikes = useSelector(state => state.highestAndLowestCommentCount[1])\r\n\r\n    const generateSentimentField = () => {\r\n        const headings = ['Highest Sentiment', 'Lowest Sentiment', 'Average Sentiment']\r\n        let output = []\r\n        for(let heading of headings) {\r\n            output.push(\r\n                <div className=\"max_c_element\" key={uuidv4()}>\r\n                    <span className=\"title-card\">\r\n                        <div>{heading}</div>\r\n                        <span \r\n                            className=\"text\" \r\n                            style={\r\n                                heading === 'Lowest Sentiment' ? \r\n                                styleLowest : heading === 'Highest Sentiment' ? \r\n                                styleHighest : average}>\r\n                            {   \r\n                                heading === 'Highest Sentiment' ? \r\n                                highestComment && (highestComment[0] > 0 ? '+' : '') + highestComment[0].toString().slice(0, 5) :\r\n                                heading === 'Lowest Sentiment' ?\r\n                                lowestComment && (lowestComment[0] > 0 ? '+' : '') + lowestComment[0].toString().slice(0, 5) :\r\n                                (sentiment > 0 ? '+' : '') + sentiment.toString().slice(0, 4)\r\n                            }\r\n                        </span>\r\n                    </span>\r\n                    {\r\n                        heading === 'Highest Sentiment' || heading === 'Lowest Sentiment' ?\r\n                        (\r\n                            <div className=\"sentiment\">\r\n                                {\r\n                                    heading === 'Highest Sentiment' ? \r\n                                    `\"${highestComment[1]}\"` : heading === 'Lowest Sentiment' ? \r\n                                    `\"${lowestComment[1]}\"` : null\r\n                                }\r\n                            </div>\r\n                        ) : null\r\n                    }\r\n                    {\r\n                        heading === 'Average Sentiment' ? \r\n                        (\r\n                            <div className=\"average-card\">\r\n                                <div className=\"sentiment\">\r\n                                    Negative Sentiments: {sentimentCount[0]}\r\n                                </div>\r\n                                <div className=\"sentiment\">\r\n                                    Neutral Sentiments: {sentimentCount[1]}\r\n                                </div>\r\n                                <div className=\"sentiment\">\r\n                                    Positive Sentiments: {sentimentCount[2]}\r\n                                </div>\r\n                            </div>\r\n                        ) : null\r\n                    }\r\n                    {\r\n                        heading === 'Lowest Sentiment' ? \r\n                        (\r\n                            <div className=\"comment-likes\">\r\n                                Likes: \r\n                                {lowestCommentLikes}\r\n                            </div>\r\n                        ) : heading === 'Highest Sentiment' ?\r\n                        (\r\n                            <div className=\"comment-likes\">\r\n                                Likes: \r\n                                {highestCommentLikes}\r\n                            </div>\r\n                        ) : (\r\n                            <div className=\"comment-likes\">\r\n                                Comments: {sentimentCount.reduce((a, b) => a + b)}\r\n                            </div>\r\n                        )\r\n                    }\r\n                </div>\r\n            )\r\n        }\r\n        return output\r\n    }\r\n\r\n    return (\r\n        <div className=\"maxcomments\">\r\n            {generateSentimentField()}\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default MaxComments\r\n","import React from 'react'\r\n\r\nfunction TitleStats({videoTitle, sentimentCount}) {\r\n\r\n    return (\r\n        <div className=\"TitleStats\">\r\n            <h2>{videoTitle}</h2>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default TitleStats\r\n","import React, { useState, Fragment, useEffect } from 'react'\r\nimport { useSelector} from 'react-redux'\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport InfiniteScroll from 'react-infinite-scroller';\r\n\r\nconst sort = (comments, indicator) => {\r\n    let sorted = []\r\n    let values = []\r\n\r\n    for(let comment of comments) {\r\n        values.push(comment[3])\r\n    }\r\n\r\n    if(indicator === '+') {\r\n        values = values.sort((a, b) => a - b).reverse()    \r\n    } else {\r\n        values = values.sort((a, b) => a - b)\r\n    }\r\n    \r\n    \r\n    for(let value of values) {\r\n        for(let comment of comments) {\r\n            if(comment[3] === value) {\r\n                sorted.push(comment)\r\n            }\r\n        }\r\n    }\r\n\r\n    return sorted\r\n}\r\n\r\nconst filterComments = (comments) => {\r\n    let positive = []\r\n    let negative = []\r\n    for(let comment of comments) {\r\n        if(comment[3] > 0) {\r\n            positive.push(comment)\r\n        } else if(comment[3] < 0) {\r\n            negative.push(comment)\r\n        }\r\n    }\r\n\r\n    positive = sort(positive, '+')\r\n    negative = sort(negative, '-')\r\n\r\n    return [positive, negative]\r\n}\r\n\r\nfunction InfiniteScrollWindow() {\r\n\r\n    let comments = useSelector(state => state.comments)\r\n    let [commentsFiltered, setCommentsFiltered] = useState()\r\n    let [positiveComments, setPositiveComments] = useState()\r\n    let [negativeComments, setNegativeComments] = useState()\r\n\r\n    useEffect(() => {\r\n        setCommentsFiltered(filterComments(comments))\r\n    }, [comments])\r\n\r\n    useEffect(() => {\r\n        commentsFiltered && setPositiveComments(commentsFiltered[0].slice(0, 10))\r\n        commentsFiltered && setNegativeComments(commentsFiltered[1].slice(0, 10))\r\n    }, [commentsFiltered])\r\n\r\n    const [hasmoreItems, setHasmoreItems] = useState(true)\r\n    \r\n    const loadMorePositive = () => {\r\n        let count = positiveComments.length + 5\r\n        if(count >= commentsFiltered[0].length) {\r\n            setHasmoreItems(false)\r\n            return\r\n        }\r\n        setPositiveComments(commentsFiltered[0].slice(0, count))\r\n    }\r\n\r\n    const loadMoreNegative = () => {\r\n        let count = negativeComments.length + 5\r\n        if(count >= commentsFiltered[1].length) {\r\n            setHasmoreItems(false)\r\n            return\r\n        }\r\n        setNegativeComments(commentsFiltered[1].slice(0, count))\r\n    }\r\n\r\n    if(!positiveComments || !negativeComments) return null\r\n    return (\r\n        <div className=\"infinite-wrapper\">\r\n            <div className=\"infiniteScroll\">\r\n                <InfiniteScroll\r\n                    className=\"infinite-comment-wrapper\"\r\n                    pageStart={0}\r\n                    loadMore={ loadMorePositive }\r\n                    hasMore={hasmoreItems}\r\n                    loader={<div className=\"loader\" key={0}>Loading ...</div>}\r\n                    useWindow={false}\r\n                    getScrollParent={() => document.getElementsByClassName('infiniteScroll')[0]}\r\n                >\r\n                    { \r\n                        positiveComments && positiveComments.map(comment => {\r\n                            return (\r\n                                <div className=\"comment-infinite-wrapper\" key={uuidv4()}>\r\n                                    <div className=\"comment-text\">{`\"${comment[0]}\"`}</div>\r\n                                    <div className=\"comment-sentiment\">{comment[3].toString().slice(0, 6)}</div>\r\n                                </div>\r\n                            )\r\n                        })\r\n                    }\r\n                </InfiniteScroll>\r\n            </div>\r\n            <div className=\"infiniteScroll\">\r\n                <InfiniteScroll\r\n                    className=\"infinite-comment-wrapper\"\r\n                    pageStart={0}\r\n                    loadMore={ loadMoreNegative }\r\n                    hasMore={hasmoreItems}\r\n                    loader={<div className=\"loader\" key={0}>Loading ...</div>}\r\n                    useWindow={false}\r\n                    getScrollParent={() => document.getElementsByClassName('infiniteScroll')[1]}\r\n                >\r\n                    { \r\n                        negativeComments && negativeComments.map(comment => {\r\n                            return (\r\n                                <div className=\"comment-infinite-wrapper\" key={uuidv4()}>\r\n                                    <div className=\"comment-text\">{`\"${comment[0]}\"`}</div>\r\n                                    <div className=\"comment-sentiment\">{comment[3].toString().slice(0, 6)}</div>\r\n                                </div>\r\n                            )\r\n                        })\r\n                    }\r\n                </InfiniteScroll>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default InfiniteScrollWindow\r\n","import React from 'react'\r\nimport { useSelector } from 'react-redux'\r\nimport Bubblechart from './Bubblechart'\r\nimport MaxComments from './MaxComments'\r\nimport TitleStats from './TitleStats'\r\nimport InfiniteScrollWindow from './InfiniteScrollWindow'\r\n\r\nfunction Display() {\r\n\r\n    const sentiment = useSelector(state => state.sentiment.sentiment)\r\n    const sentimentCount = useSelector(state => state.sentiment.sentimentCount)\r\n    const highestComment = useSelector(state => state.sentiment.highestComment)\r\n    const lowestComment = useSelector(state => state.sentiment.lowestComment)\r\n    const videoTitle = useSelector(state => state.videoTitle)\r\n    const keyCounts = useSelector(state => state.keyCounts)\r\n    const commentCount = useSelector(state => state.sentiment.commentCount)\r\n    const singleWordSentiments = useSelector(state => state.singleWordSentiments)\r\n\r\n    if(!sentiment) return null\r\n    return (\r\n        <div className=\"Display\">\r\n            <TitleStats videoTitle={videoTitle} />\r\n            <MaxComments \r\n                sentimentCount={sentimentCount} \r\n                lowestComment={lowestComment} \r\n                highestComment={highestComment} \r\n                sentiment={sentiment} \r\n            />\r\n            <InfiniteScrollWindow />\r\n            <Bubblechart data={keyCounts} dataSingleWords={singleWordSentiments}/>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Display\r\n","import React from 'react'\nimport Settings from './components/Settings'\nimport Display from './components/Display'\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <h1>Consensus</h1>\n      <p className=\"subheading\">AFINN Youtube Sentiment Analysis</p>\n      <Settings />\n      <Display />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import { \r\n    SET_SENTIMENT, \r\n    SET_SENTIMENT_COUNT, \r\n    SET_HIGHEST_COMMENT, \r\n    SET_LOWEST_COMMENT, \r\n    SET_COMMENT_COUNT\r\n} from '../actions/constants'\r\n\r\nconst initialState = {\r\n    sentiment: 0,\r\n    sentimentCount: [null, null],\r\n    highestComment: '',\r\n    lowestComment: '',\r\n    commentCount: 0\r\n}\r\n\r\nexport const sentiment = (state = initialState, action) => {\r\n    switch(action.type) {\r\n        case SET_SENTIMENT:\r\n            return {\r\n                ...state,\r\n                sentiment: action.sentiment\r\n            }\r\n        case SET_SENTIMENT_COUNT:\r\n            return {\r\n                ...state,\r\n                sentimentCount: action.sentimentCount\r\n            }\r\n        case SET_HIGHEST_COMMENT:\r\n            return {\r\n                ...state,\r\n                highestComment: action.highestComment\r\n            }\r\n        case SET_LOWEST_COMMENT:\r\n            return {\r\n                ...state,\r\n                lowestComment: action.lowestComment\r\n            }\r\n        case SET_COMMENT_COUNT:\r\n            return {\r\n                ...state,\r\n                commentCount: action.commentCount\r\n            }\r\n        default:\r\n            return state\r\n    }\r\n}","import { \r\n    SET_HIGHEST_SENTIMENT_SINGLE_WORDS, \r\n    SET_LOWEST_SENTIMENT_SINGLE_WORDS\r\n} from '../actions/constants'\r\n\r\nconst initialState = {\r\n    highestSingleWords: [],\r\n    lowestSingleWords: []\r\n}\r\n\r\nexport const singleWordSentiments = (state = initialState, action) => {\r\n    switch(action.type) {\r\n        case SET_HIGHEST_SENTIMENT_SINGLE_WORDS:\r\n            return {\r\n                ...state,\r\n                highestSingleWords: action.highestSingleWords\r\n            }\r\n        case SET_LOWEST_SENTIMENT_SINGLE_WORDS:\r\n            return {\r\n                ...state,\r\n                lowestSingleWords: action.lowestSingleWords\r\n            }\r\n        default:\r\n            return state\r\n    }\r\n}","import { combineReducers } from 'redux'\r\nimport { videoTitle } from './videoTitle'\r\nimport { sentiment } from './sentiment'\r\nimport { keyCounts } from './keyCounts'\r\nimport { comments } from './comments'\r\nimport { highestAndLowestCommentCount } from './highestAndLowestCommentCount'\r\nimport { singleWordSentiments } from './singleWordSentiments'\r\nimport { countries } from './countries'\r\nimport { choice } from './choice'\r\n\r\nexport default combineReducers({\r\n    videoTitle,\r\n    sentiment,\r\n    keyCounts,\r\n    comments,\r\n    highestAndLowestCommentCount,\r\n    singleWordSentiments,\r\n    countries,\r\n    choice\r\n})","import { SET_VIDEO_TITLE } from '../actions/constants'\r\n\r\nexport const videoTitle = (state = '', action) => {\r\n    switch(action.type) {\r\n        case SET_VIDEO_TITLE:\r\n            return action.videoTitle\r\n        default:\r\n            return state\r\n    }\r\n}","import { SET_KEYCOUNTS } from '../actions/constants'\r\n\r\nexport const keyCounts = (state = {}, action) => {\r\n    switch(action.type) {\r\n        case SET_KEYCOUNTS:\r\n            return action.keyCounts\r\n        default:\r\n            return state\r\n    }\r\n}","import { SET_COMMENTS } from '../actions/constants'\r\n\r\nexport const comments = (state = {}, action) => {\r\n    switch(action.type) {\r\n        case SET_COMMENTS:\r\n            return action.comments\r\n        default:\r\n            return state\r\n    }\r\n}","import { SET_HIGHEST_AND_LOWEST_COMMENT_COUNT } from '../actions/constants'\r\n\r\nexport const highestAndLowestCommentCount = (state = {}, action) => {\r\n    switch(action.type) {\r\n        case SET_HIGHEST_AND_LOWEST_COMMENT_COUNT:\r\n            return action.highLowCommentCount\r\n        default:\r\n            return state\r\n    }\r\n}","import { SET_COUNTRIES } from '../actions/constants'\r\n\r\nexport const countries = (state = [], action) => {\r\n    switch(action.type) {\r\n        case SET_COUNTRIES:\r\n            return action.countries\r\n        default:\r\n            return state\r\n    }\r\n}","import { SET_CHOICE } from '../actions/constants'\r\n\r\nexport const choice = (state = 'keywords', action) => {\r\n    switch(action.type) {\r\n        case SET_CHOICE:\r\n            return action.choice\r\n        default:\r\n            return state\r\n    }\r\n}","import { createStore, applyMiddleware } from 'redux'\r\nimport { composeWithDevTools } from 'redux-devtools-extension'\r\nimport thunk from 'redux-thunk'\r\nimport rootReducer from '../reducers'\r\n\r\nconst initialState = {}\r\n\r\nconst middleware = [thunk]\r\n\r\nconst store = createStore(rootReducer, initialState, composeWithDevTools(applyMiddleware(...middleware)))\r\n\r\nexport default store","import 'react-app-polyfill/ie9'\nimport 'react-app-polyfill/stable'\nimport \"core-js/stable\"\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\nimport * as serviceWorker from './serviceWorker'\nimport store from './store'\nimport { Provider } from 'react-redux'\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}