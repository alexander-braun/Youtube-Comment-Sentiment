{"version":3,"sources":["actions/setVideoTitle.js","actions/constants.js","actions/setComments.js","actions/setSentiments.js","components/helper/keywords_helper.js","components/helper/likes_helper.js","components/helper/sentiments_helper.js","components/helper/fetchComments_helper.js","components/helper/fetchVideoTitle_helper.js","components/helper/cleanComments_helper.js","components/SearchStyles.js","components/NoCommentsModal.js","actions/toggleNoCommentsModal.js","components/Search.js","components/helper/shoertenToVideoID_helper.js","actions/setSingleWordSentiments.js","actions/setHighestAndLowestCommentCount.js","actions/setKeycounts.js","components/Resizeobserver.js","components/Bubblechart.js","actions/setChoice.js","components/HighestLowestAverage.js","components/helper/filterComments_helper.js","components/InfiniteScrollWindow.js","components/Display.js","App.js","reducers/sentiment.js","reducers/singleWordSentiments.js","reducers/index.js","reducers/videoTitle.js","reducers/keyCounts.js","reducers/comments.js","reducers/highestAndLowestCommentCount.js","reducers/choice.js","reducers/noCommentsModal.js","store/index.js","index.js"],"names":["setVideoTitle","videoTitle","type","setComments","comments","setCommentCount","commentCount","keyword_extractor","require","countKeywords","keywords","uniqueKeywords","i","length","word","toLowerCase","indexOf","push","keyCount","keyword","getKeywordsFromComments","extraction","extract","language","remove_digits","return_changed_case","remove_duplicates","findLikesForHighestAndLowestComment","highest","lowest","highestCommentLikes","lowestCommentLikes","comment","Analyzer","SentimentAnalyzer","stemmer","PorterStemmer","singleWordSentiments","tokenized","lowWords","highWords","analyzer","sentimentSingle","j","obj","parseFloat","getSentiment","sentiments","highestLowestWords","split","getHighestAndLowestSingleWordSentiments","wholeWordSentiments","sentimentCount","sentiment","isNaN","getWholeCommentSentiment","highestComment","lowestComment","apiKey","process","fetchComments","videoID","ID","a","textArr","token","undefined","maxResults","url","fetch","response","json","data","error","code","nextPageToken","map","splitcomment","fetchVideoTitle","title","cleanComments","cleanedComments","SearchStyles","makeStyles","theme","searchIcon","color","position","right","cursor","fontSize","NoCommentsModal","dispatch","useDispatch","className","onClick","connect","state","noCommentsModal","useState","videoLink","updateVideoLink","updateVideoID","useEffect","link","equalSignIndex","search","slice","shoertenToVideoID","getSearchResults","e","preventDefault","flat","sentimentCollector","lowestSingleWords","highestSingleWords","likes","highLowCommentCount","uniqueKeywordCounts","keyCounts","classes","console","log","placeholder","id","name","onChange","target","value","useResizeObserver","ref","dimensions","setDimensions","observeTarget","current","resizeObserver","ResizeObserver","entries","forEach","entry","contentRect","observe","unobserve","Bubblechart","dataSingleWords","svgRef","useRef","wrapperRef","Object","scoreValues","newEntries","Number","sort","b","scoreCount","window","innerWidth","filter","arr","heighestXEntries","cleanEntries","amount","sentimentWordsCombined","category","keys","bubbles2Count","width","count","key","minValue","maxValue","choice","updateChoice","dataChoice","useCallback","minMaxNumbers","d3","svg","select","mouseEnter","selectAll","join","enter","append","attr","node","element","height","style","colorScale","colorScaleS","text","x","scaleOrdinal","domain","Set","range","scaleLinear","scaleBubbles","scaleL","scaleLS","xCenter","forceSimulation","force","forceManyBody","strength","d","forceCenter","forceCollide","radius","Math","abs","on","y","remove","handleChange","setChoice","document","getElementById","classList","add","HighestLowestAverage","useSelector","highestAndLowestCommentCount","styleHighest","styleLowest","average","output","heading","uuidv4","toString","reduce","generateSentimentField","sortCommentsBySentiment","indicator","sorted","values","index","reverse","usedIndexes","InfiniteScrollWindow","commentsFiltered","setCommentsFiltered","positiveComments","setPositiveComments","negativeComments","setNegativeComments","hasmoreItems","setHasmoreItems","positive","negative","filterComments","pageStart","loadMore","hasMore","loader","useWindow","getScrollParent","getElementsByClassName","Display","App","initialState","combineReducers","action","middleware","thunk","store","createStore","rootReducer","composeWithDevTools","applyMiddleware","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.30b0fe4c.chunk.js","sourcesContent":["import { SET_VIDEO_TITLE } from './constants';\r\n\r\nexport const setVideoTitle = (videoTitle) => ({\r\n  type: SET_VIDEO_TITLE,\r\n  videoTitle,\r\n});\r\n","export const SET_VIDEO_TITLE = 'SET_VIDEO_TITLE';\nexport const SET_SENTIMENT = 'SET_SENTIMENT';\nexport const SET_SENTIMENT_COUNT = 'SET_SENTIMENT_COUNT';\nexport const SET_HIGHEST_COMMENT = 'SET_HIGHEST_COMMENT';\nexport const SET_LOWEST_COMMENT = 'SET_LOWEST_COMMENT';\nexport const SET_KEYCOUNTS = 'SET_KEYCOUNTS';\nexport const SET_COMMENT_COUNT = 'SET_COMMENT_COUNT';\nexport const SET_COMMENTS = 'SET_COMMENTS';\nexport const SET_HIGHEST_AND_LOWEST_COMMENT_COUNT =\n  'SET_HIGHEST_AND_LOWEST_COMMENT_COUNT';\nexport const SET_HIGHEST_SENTIMENT_SINGLE_WORDS =\n  'SET_HIGHEST_SENTIMENT_SINGLE_WORD';\nexport const SET_LOWEST_SENTIMENT_SINGLE_WORDS =\n  'SET_LOWEST_SENTIMENT_SINGLE_WORD';\nexport const SET_CHOICE = 'SET_CHOICE';\nexport const TOGGLE_NO_COMMENTS_MODAL = 'TOGGLE_NO_COMMENTS_MODAL';\n","import { SET_COMMENTS } from './constants';\r\n\r\nexport const setComments = (comments) => ({\r\n  type: SET_COMMENTS,\r\n  comments,\r\n});\r\n","import {\r\n  SET_SENTIMENT,\r\n  SET_SENTIMENT_COUNT,\r\n  SET_HIGHEST_COMMENT,\r\n  SET_LOWEST_COMMENT,\r\n  SET_COMMENT_COUNT,\r\n} from './constants';\r\n\r\nexport const setSentiment = (sentiment) => ({\r\n  type: SET_SENTIMENT,\r\n  sentiment,\r\n});\r\n\r\nexport const setSentimentCount = (sentimentCount) => ({\r\n  type: SET_SENTIMENT_COUNT,\r\n  sentimentCount,\r\n});\r\n\r\nexport const setHighestComment = (highestComment) => ({\r\n  type: SET_HIGHEST_COMMENT,\r\n  highestComment,\r\n});\r\n\r\nexport const setLowestComment = (lowestComment) => ({\r\n  type: SET_LOWEST_COMMENT,\r\n  lowestComment,\r\n});\r\n\r\nexport const setCommentCount = (commentCount) => ({\r\n  type: SET_COMMENT_COUNT,\r\n  commentCount,\r\n});\r\n","const keyword_extractor = require('keyword-extractor');\r\n\r\n/**\r\n * Counts Keywords for the bubblechart comparsion\r\n */\r\nexport const countKeywords = (keywords) => {\r\n  // Get all the unique keywords\r\n  const uniqueKeywords = [];\r\n  for (let i = 0; i < keywords.length; i++) {\r\n    for (const keyword of keywords[i]) {\r\n      const word = keyword.toLowerCase();\r\n      uniqueKeywords.indexOf(word) === -1 && uniqueKeywords.push(word);\r\n    }\r\n  }\r\n\r\n  // Put all of them into an object an count them\r\n  const keyCount = {};\r\n  for (let i = 0; i < keywords.length; i++) {\r\n    for (const keyword of keywords[i]) {\r\n      keyCount[keyword] && keyCount[keyword]++;\r\n      !keyCount[keyword] && (keyCount[keyword] = 1);\r\n    }\r\n  }\r\n  return keyCount;\r\n};\r\n\r\n/**\r\n * Gets english lang keywords with the help of keywordextractor\r\n * from all the comments for the bubblechart\r\n */\r\nexport const getKeywordsFromComments = (comments) => {\r\n  let keywords = [];\r\n  for (let i = 0; i < comments.length; i++) {\r\n    let extraction = keyword_extractor.extract(comments[i], {\r\n      language: 'english',\r\n      remove_digits: true,\r\n      return_changed_case: true,\r\n      remove_duplicates: false,\r\n    });\r\n    keywords.push(extraction);\r\n  }\r\n  return keywords;\r\n};\r\n","/**\r\n * Takes the highest and lowest comments and gets the like count\r\n */\r\nexport const findLikesForHighestAndLowestComment = (\r\n  highest,\r\n  lowest,\r\n  comments\r\n) => {\r\n  let highestCommentLikes = 0;\r\n  let lowestCommentLikes = 0;\r\n  for (const comment of comments) {\r\n    if (comment[0] === highest[1]) {\r\n      highestCommentLikes = comment[1];\r\n    }\r\n    if (comment[0] === lowest[1]) {\r\n      lowestCommentLikes = comment[1];\r\n    }\r\n  }\r\n  return [highestCommentLikes, lowestCommentLikes];\r\n};\r\n","var Analyzer = require('natural').SentimentAnalyzer;\r\nvar stemmer = require('natural').PorterStemmer;\r\n\r\n/**\r\n * Goes through all the comments and finds words <= -1 or >= 1 and puts them in an array\r\n * Counts positive, neutral and negative comments\r\n * Finds the highest and lowest sentiment comments\r\n * Gets the overall sentiment\r\n */\r\n\r\nconst singleWordSentiments = (tokenized, lowWords, highWords, analyzer) => {\r\n  let sentimentSingle;\r\n  for (let j = 0; j < tokenized.length; j++) {\r\n    sentimentSingle = parseFloat(analyzer.getSentiment([tokenized[j]]));\r\n    let obj = {};\r\n    if (sentimentSingle <= -1) {\r\n      obj['word'] = tokenized[j];\r\n      obj['sentiment'] = sentimentSingle;\r\n      lowWords.push(obj);\r\n    } else if (sentimentSingle >= 1) {\r\n      obj['word'] = tokenized[j];\r\n      obj['sentiment'] = sentimentSingle;\r\n      highWords.push(obj);\r\n    }\r\n  }\r\n};\r\n\r\nconst getWholeCommentSentiment = (comments, length) => {\r\n  const analyzer = new Analyzer('English', stemmer, 'afinn');\r\n\r\n  let highest = [-10, null];\r\n  let lowest = [10, null];\r\n  let sentimentCount = [0, 0, 0];\r\n  let sentiments = parseFloat(0);\r\n\r\n  for (let i = 0; i < length; i++) {\r\n    let tokenized = comments[i].split(' ');\r\n    const sentiment = parseFloat(analyzer.getSentiment(tokenized));\r\n\r\n    sentiment > 0 && sentimentCount[2]++;\r\n    sentiment === 0 && sentimentCount[1]++;\r\n    sentiment < 0 && sentimentCount[0]++;\r\n\r\n    sentiment > highest[0] &&\r\n      (highest[0] = sentiment) &&\r\n      (highest[1] = comments[i]);\r\n    sentiment < lowest[0] &&\r\n      (lowest[0] = sentiment) &&\r\n      (lowest[1] = comments[i]);\r\n\r\n    if (!isNaN(sentiment)) {\r\n      sentiments += sentiment;\r\n    }\r\n  }\r\n\r\n  return [highest, lowest, sentimentCount, sentiments];\r\n};\r\n\r\nconst getHighestAndLowestSingleWordSentiments = (comments, length) => {\r\n  let analyzer = new Analyzer('English', stemmer, 'afinn');\r\n\r\n  // Array of objects collecting words <= -1 or >= 1\r\n  let lowWords = [];\r\n  let highWords = [];\r\n\r\n  for (let i = 0; i < length; i++) {\r\n    let tokenized = comments[i].split(' ');\r\n    // Get the single word sentiments\r\n    singleWordSentiments(tokenized, lowWords, highWords, analyzer, i);\r\n  }\r\n\r\n  return [highWords, lowWords];\r\n};\r\n\r\nexport const sentiments = (comments) => {\r\n  let length = comments.length;\r\n  const highestLowestWords = getHighestAndLowestSingleWordSentiments(\r\n    comments,\r\n    length\r\n  );\r\n  const highWords = highestLowestWords[0];\r\n  const lowWords = highestLowestWords[1];\r\n\r\n  const wholeWordSentiments = getWholeCommentSentiment(comments, length);\r\n  const highestComment = wholeWordSentiments[0];\r\n  const lowestComment = wholeWordSentiments[1];\r\n  const sentimentCount = wholeWordSentiments[2];\r\n  const sentiments = wholeWordSentiments[3];\r\n  return [\r\n    sentiments / length,\r\n    sentimentCount,\r\n    highestComment,\r\n    lowestComment,\r\n    lowWords,\r\n    highWords,\r\n  ];\r\n};\r\n","var Analyzer = require('natural').SentimentAnalyzer;\r\nvar stemmer = require('natural').PorterStemmer;\r\nlet apiKey = process.env.REACT_APP_API_KEY;\r\n\r\n// Connection to the youtube API -> setup to get more then 100 comments (all the comments f.e.) but too much api cost atm\r\nexport const fetchComments = (videoID) => {\r\n  let ID = videoID;\r\n  let maxResults = 100;\r\n  let analyzer = new Analyzer('English', stemmer, 'afinn');\r\n\r\n  // Recursive Function to get each 100 comments\r\n  async function fetchComments(textArr = [], token) {\r\n    // If there are X comments already in array return array\r\n    if (textArr[0] !== undefined) {\r\n      // Every array has 100 comments in it so maxResults / 100 >= textArr.length tests if the maxResult-propertie is fullfilled\r\n      if (maxResults / 100 >= textArr.length) {\r\n        return textArr;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Change the url based on the existence of a nextpagetoken\r\n     * Setup and working for future use but API cost was too high\r\n     */\r\n    let url;\r\n    if (token) {\r\n      url = `https://www.googleapis.com/youtube/v3/commentThreads?key=${apiKey}&textFormat=plainText&part=snippet&videoId=${ID}&maxResults=${maxResults}&pageToken=${token}`;\r\n    } else {\r\n      url = `https://www.googleapis.com/youtube/v3/commentThreads?key=${apiKey}&textFormat=plainText&part=snippet&videoId=${ID}&maxResults=${maxResults}`;\r\n    }\r\n\r\n    // Grab the data and get comment and likecount for comment\r\n    let comments, nextPageToken;\r\n\r\n    const response = await fetch(url);\r\n    const data = await response.json();\r\n    if (data.error && data.error.code === 403) {\r\n      return false;\r\n    }\r\n    nextPageToken = await data['nextPageToken'];\r\n    comments = await data['items'];\r\n\r\n    // If the address was f.e. empty and there are no results just return []\r\n    if (!comments) return [];\r\n\r\n    // Else put the comments and the likecount (not used yet) into an array\r\n    comments = comments.map((comment) => {\r\n      const splitcomment = comment['snippet']['topLevelComment']['snippet'][\r\n        'textDisplay'\r\n      ].split(' ');\r\n      return [\r\n        comment['snippet']['topLevelComment']['snippet']['textDisplay'],\r\n        comment['snippet']['topLevelComment']['snippet']['likeCount'],\r\n        comment['snippet']['topLevelComment']['snippet']['authorChannelId'][\r\n          'value'\r\n        ],\r\n        analyzer.getSentiment(splitcomment),\r\n        comment['snippet']['topLevelComment']['snippet']['authorChannelUrl'],\r\n      ];\r\n    });\r\n\r\n    // Push data to array that is passed along\r\n    textArr.push(comments);\r\n\r\n    /**\r\n     * If there is one more comment page to load grab the nextpagetoken for that site\r\n     * Not used as it eats the free api usage too quickly. Could grab all other comments\r\n     * If used\r\n     */\r\n    if (nextPageToken) {\r\n      return fetchComments(textArr, nextPageToken);\r\n    }\r\n\r\n    // Or else just return the array\r\n    else if (!nextPageToken) return textArr;\r\n  }\r\n\r\n  return fetchComments([], null);\r\n};\r\n","/**\r\n * Uses the noembed site to get the video title, reduces api cost\r\n */\r\nexport const fetchVideoTitle = async (ID) => {\r\n  if (ID && ID !== undefined) {\r\n    let url = `https://noembed.com/embed?url=https%3A%2F%2Fhttps://www.youtube.com/watch?v=${ID}`;\r\n    const response = await fetch(url);\r\n    const data = await response.json();\r\n    const title = await data['title'];\r\n    return title;\r\n  }\r\n  return null;\r\n};\r\n","/**\r\n * Seperates the pure text from additional information wich are not needed in this step\r\n */\r\nexport const cleanComments = (comments) => {\r\n  let cleanedComments = [];\r\n  for (let i = 0; i < comments.length; i++) {\r\n    cleanedComments.push(comments[i][0]);\r\n  }\r\n  return cleanedComments;\r\n};\r\n","//MUI\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nexport const SearchStyles = makeStyles((theme) => ({\r\n  searchIcon: {\r\n    color: 'rgba(128, 128, 128, 0.5)',\r\n    position: 'absolute',\r\n    right: '10px',\r\n    cursor: 'pointer',\r\n    fontSize: '2.25rem',\r\n  },\r\n}));\r\n","import React from 'react';\r\nimport { useDispatch } from 'react-redux';\r\n\r\nimport { toggleNoCommentsModal } from '../actions/toggleNoCommentsModal';\r\n\r\nconst NoCommentsModal = () => {\r\n  const dispatch = useDispatch();\r\n  return (\r\n    <div className=\"no-comments-modal\">\r\n      <div\r\n        className=\"no-comments-modal__close-button\"\r\n        onClick={() => dispatch(toggleNoCommentsModal())}\r\n      >\r\n        CLOSE X\r\n      </div>\r\n      <div className=\"no-comments-modal__text\">\r\n        The video has no comments or comments are deactivated, sry :(\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default NoCommentsModal;\r\n","import { TOGGLE_NO_COMMENTS_MODAL } from './constants';\r\n\r\nexport const toggleNoCommentsModal = () => ({\r\n  type: TOGGLE_NO_COMMENTS_MODAL,\r\n});\r\n","import React, { useState, useEffect } from 'react';\r\nimport { useDispatch } from 'react-redux';\r\nimport { connect } from 'react-redux';\r\n\r\n//MUI\r\nimport SearchIcon from '@material-ui/icons/Search';\r\n\r\n//Actions\r\nimport { setKeycounts } from '../actions/setKeycounts';\r\nimport { setVideoTitle } from '../actions/setVideoTitle';\r\nimport { setComments } from '../actions/setComments';\r\nimport { setHighestAndLowestCommentCount } from '../actions/setHighestAndLowestCommentCount';\r\nimport { toggleNoCommentsModal } from '../actions/toggleNoCommentsModal';\r\nimport {\r\n  setHighestSingleWords,\r\n  setLowestSingleWords,\r\n} from '../actions/setSingleWordSentiments';\r\nimport {\r\n  setSentiment,\r\n  setSentimentCount,\r\n  setHighestComment,\r\n  setLowestComment,\r\n  setCommentCount,\r\n} from '../actions/setSentiments';\r\n\r\n//Helper\r\nimport { getKeywordsFromComments } from './helper/keywords_helper';\r\nimport { countKeywords } from './helper/keywords_helper';\r\nimport { findLikesForHighestAndLowestComment } from './helper/likes_helper';\r\nimport { sentiments } from './helper/sentiments_helper';\r\nimport { fetchComments } from './helper/fetchComments_helper';\r\nimport { fetchVideoTitle } from './helper/fetchVideoTitle_helper';\r\nimport { cleanComments } from './helper/cleanComments_helper';\r\nimport { shoertenToVideoID } from './helper/shoertenToVideoID_helper';\r\n\r\n//Assets\r\nimport { SearchStyles } from './SearchStyles';\r\n\r\n//Components\r\nimport NoCommentsModal from './NoCommentsModal';\r\n\r\nfunction Search({ noCommentsModal }) {\r\n  const [videoLink, updateVideoLink] = useState('');\r\n  const [videoID, updateVideoID] = useState();\r\n  const dispatch = useDispatch();\r\n\r\n  useEffect(() => {\r\n    // Get and Update Video ID when videoLink updates\r\n    const ID = shoertenToVideoID(videoLink);\r\n    updateVideoID(ID);\r\n  }, [videoLink]);\r\n\r\n  // Main knot to get all needed information from the api\r\n  const getSearchResults = async (e) => {\r\n    e.preventDefault();\r\n\r\n    // Get and set Video Title\r\n    let videoTitle = await fetchVideoTitle(videoID);\r\n    dispatch(setVideoTitle(videoTitle));\r\n\r\n    // Get last 100 comments (YT always returns 100 if there are at least 100 comments)\r\n    let comments = await fetchComments(videoID);\r\n    //Method returns false when comments are deactivated\r\n    if (!comments || comments.length === 0) {\r\n      return dispatch(toggleNoCommentsModal());\r\n    }\r\n    if (comments.length === 0) return;\r\n    comments = comments.flat();\r\n    dispatch(setComments(comments));\r\n\r\n    // Extract pure comments from [comment, likes, id]\r\n    let cleanedComments = cleanComments(comments);\r\n    let commentCount = cleanedComments.length;\r\n    dispatch(setCommentCount(commentCount));\r\n\r\n    // Calculate the sentiment and update\r\n    let sentimentCollector = sentiments(cleanedComments);\r\n    dispatch(setSentiment(sentimentCollector[0]));\r\n    dispatch(setSentimentCount(sentimentCollector[1]));\r\n    dispatch(setHighestComment(sentimentCollector[2]));\r\n    dispatch(setLowestComment(sentimentCollector[3]));\r\n    dispatch(setLowestSingleWords(sentimentCollector[4]));\r\n    dispatch(setHighestSingleWords(sentimentCollector[5]));\r\n\r\n    // Get and set the likes for the highest and lowest sentiment comments\r\n    let likes = findLikesForHighestAndLowestComment(\r\n      sentimentCollector[2],\r\n      sentimentCollector[3],\r\n      comments\r\n    );\r\n    dispatch(setHighestAndLowestCommentCount(likes));\r\n\r\n    // Get all the keywords from all the comments and count them\r\n    let keywords = getKeywordsFromComments(cleanedComments);\r\n    let uniqueKeywordCounts = countKeywords(keywords);\r\n    dispatch(setKeycounts(uniqueKeywordCounts));\r\n  };\r\n\r\n  const classes = SearchStyles();\r\n  console.log(noCommentsModal);\r\n  return (\r\n    <div className=\"search\">\r\n      <form className=\"search__form\">\r\n        <input\r\n          placeholder=\"Enter Youtube Video Link...\"\r\n          type=\"text\"\r\n          id=\"video-link\"\r\n          name=\"video-link\"\r\n          onChange={(e) => updateVideoLink(e.target.value)}\r\n          value={videoLink}\r\n          className=\"search__link-input\"\r\n        />\r\n        <SearchIcon className={classes.searchIcon} onClick={getSearchResults} />\r\n      </form>\r\n      <button\r\n        onClick={getSearchResults}\r\n        value=\"Search\"\r\n        className=\"search__button\"\r\n      >\r\n        Search\r\n      </button>\r\n      {noCommentsModal && <NoCommentsModal />}\r\n    </div>\r\n  );\r\n}\r\n\r\nconst mapStateToProps = (state) => ({\r\n  noCommentsModal: state.noCommentsModal,\r\n});\r\n\r\nexport default connect(mapStateToProps)(Search);\r\n","/**\r\n * Takes the video link and returns the ID\r\n */\r\nexport const shoertenToVideoID = (link) => {\r\n  const equalSignIndex = link.search('=');\r\n  const videoID = link.slice(equalSignIndex + 1);\r\n  return videoID;\r\n};\r\n","import {\r\n  SET_HIGHEST_SENTIMENT_SINGLE_WORDS,\r\n  SET_LOWEST_SENTIMENT_SINGLE_WORDS,\r\n} from './constants';\r\n\r\nexport const setHighestSingleWords = (highestSingleWords) => ({\r\n  type: SET_HIGHEST_SENTIMENT_SINGLE_WORDS,\r\n  highestSingleWords,\r\n});\r\n\r\nexport const setLowestSingleWords = (lowestSingleWords) => ({\r\n  type: SET_LOWEST_SENTIMENT_SINGLE_WORDS,\r\n  lowestSingleWords,\r\n});\r\n","import { SET_HIGHEST_AND_LOWEST_COMMENT_COUNT } from './constants';\r\n\r\nexport const setHighestAndLowestCommentCount = (highLowCommentCount) => ({\r\n  type: SET_HIGHEST_AND_LOWEST_COMMENT_COUNT,\r\n  highLowCommentCount,\r\n});\r\n","import { SET_KEYCOUNTS } from './constants';\r\n\r\nexport const setKeycounts = (keyCounts) => ({\r\n  type: SET_KEYCOUNTS,\r\n  keyCounts,\r\n});\r\n","import ResizeObserver from 'resize-observer-polyfill';\r\nimport { useEffect, useState } from 'react';\r\n\r\nconst useResizeObserver = (ref) => {\r\n  const [dimensions, setDimensions] = useState(null);\r\n  useEffect(() => {\r\n    const observeTarget = ref.current;\r\n    const resizeObserver = new ResizeObserver((entries) => {\r\n      entries.forEach((entry) => {\r\n        setDimensions(entry.contentRect);\r\n      });\r\n    });\r\n    resizeObserver.observe(observeTarget);\r\n    return () => {\r\n      resizeObserver.unobserve(observeTarget);\r\n    };\r\n  }, [ref]);\r\n  return dimensions;\r\n};\r\n\r\nexport default useResizeObserver;\r\n","import * as d3 from 'd3';\r\nimport {\r\n  select,\r\n  forceSimulation,\r\n  scaleOrdinal,\r\n  forceCollide,\r\n  forceManyBody,\r\n  forceCenter,\r\n  scaleLinear,\r\n} from 'd3';\r\nimport React, { useRef, useEffect, useState, useCallback } from 'react';\r\nimport useResizeObserver from './Resizeobserver';\r\nimport { useDispatch } from 'react-redux';\r\nimport { setChoice } from '../actions/setChoice';\r\n\r\nfunction Bubblechart({ data, dataSingleWords }) {\r\n  const svgRef = useRef();\r\n  const wrapperRef = useRef();\r\n  const dimensions = useResizeObserver(wrapperRef);\r\n  const entries = Object.entries(data);\r\n  const alphabet = 'abcdefghijklmnopqrstuvwxyz1234567890';\r\n  const dispatch = useDispatch();\r\n\r\n  let scoreValues = [];\r\n  const heighestXEntries = () => {\r\n    // Get all unique counts for a word and sort them\r\n    for (let entry of entries) {\r\n      if (scoreValues.indexOf(entry[1]) === -1)\r\n        scoreValues.push(Number(entry[1]));\r\n    }\r\n    scoreValues.sort((a, b) => a - b);\r\n\r\n    // ScoreCount is the max number of bubbles for the bubblediagram\r\n    let scoreCount = 25;\r\n    if (window.innerWidth < 700) scoreCount = 15;\r\n\r\n    // goes backwards through the scores and pushes [word, count] into newEntries\r\n    let newEntries = [];\r\n    for (let i = scoreValues.length; i > 0; i--) {\r\n      newEntries.push(\r\n        ...entries.filter((arr) => {\r\n          return arr[1] === scoreValues[i] && arr;\r\n        })\r\n      );\r\n      if (newEntries.length >= scoreCount) break;\r\n    }\r\n    return newEntries.slice(0, scoreCount);\r\n  };\r\n\r\n  let newEntries = heighestXEntries();\r\n\r\n  // Sorts the entries as object (for d3) into an array. Gets rid of single character mentions like = or -\r\n  let cleanEntries = [];\r\n  for (let entry of newEntries) {\r\n    if (entry[1] > 1) {\r\n      if (alphabet.indexOf(entry[0][0]) === -1) {\r\n        continue;\r\n      }\r\n      let obj = { word: null, amount: null };\r\n      obj['word'] = entry[0];\r\n      obj['amount'] = entry[1];\r\n      cleanEntries.push(obj);\r\n    }\r\n  }\r\n\r\n  // Merge Singlewordsentiments and assign category 0 or 1\r\n  let sentimentWordsCombined = [];\r\n  let category = 0;\r\n  let keys = Object.keys(dataSingleWords);\r\n\r\n  let bubbles2Count = 15;\r\n  if (dimensions && dimensions.width <= 700) bubbles2Count = 10;\r\n\r\n  let count = 0;\r\n\r\n  for (let key of keys) {\r\n    for (let i = 0; i < dataSingleWords[key].length; i++) {\r\n      if (count < bubbles2Count) {\r\n        let obj = dataSingleWords[key][i];\r\n        obj['category'] = category;\r\n        sentimentWordsCombined.push(obj);\r\n        count++;\r\n      }\r\n    }\r\n    count = 0;\r\n    category++;\r\n  }\r\n\r\n  // Base bubbles on choice of keywords or sentiment words\r\n  const [choice, updateChoice] = useState('keywords');\r\n  const dataChoice = useCallback(() => {\r\n    return choice === 'keywords' ? cleanEntries : sentimentWordsCombined;\r\n  }, [choice, cleanEntries, sentimentWordsCombined]);\r\n\r\n  // Gets the minValue and maxValue of word counts\r\n  let minValue;\r\n  let maxValue;\r\n\r\n  if (dataChoice().length !== 0) {\r\n    let minMaxNumbers = [];\r\n    for (let entry of dataChoice()) {\r\n      minMaxNumbers.push(entry['amount' || 'sentiment']);\r\n    }\r\n    minValue = d3.min(minMaxNumbers);\r\n    maxValue = d3.max(minMaxNumbers);\r\n  }\r\n\r\n  useEffect(() => {\r\n    let data = dataChoice();\r\n    if (!dimensions) return;\r\n    let svg = null;\r\n    svg = select(svgRef.current);\r\n\r\n    const mouseEnter = (value) => {\r\n      svg\r\n        .selectAll('.rec')\r\n        .data(() => {\r\n          if (choice === 'sentiment') {\r\n            return [[value['sentiment'], value['word']]];\r\n          } else return [[value['amount'], value['word']]];\r\n        })\r\n        .join((enter) => enter.append('rect'))\r\n        .attr('class', 'rec')\r\n        .attr('x', (node) => {\r\n          for (let element of cleanEntries) {\r\n            if (choice !== 'sentiment') {\r\n              if (element['word'] === node[1]) {\r\n                if (dimensions.width <= 700) {\r\n                  return dimensions.width / 2 - 175;\r\n                } else return element['x'] + 100;\r\n              }\r\n            } else return dimensions.width / 2 - (node[1].length * 4 + 150);\r\n          }\r\n        })\r\n        .attr('width', (node) => {\r\n          return `${node[1].length * 4 + 300}px`;\r\n        })\r\n        .attr('height', '40px')\r\n        .attr('text-anchor', 'middle')\r\n        .attr('y', (node) => {\r\n          for (let element of cleanEntries) {\r\n            if (choice !== 'sentiment') {\r\n              if (element['word'] === node[1]) {\r\n                return element['y'];\r\n              }\r\n            } else return dimensions.height / 2;\r\n          }\r\n        })\r\n        .attr('opacity', 1)\r\n        .attr('fill', 'white')\r\n        .style('stroke', (node) => {\r\n          if (choice !== 'sentiment') {\r\n            return colorScale(node[0]);\r\n          } else {\r\n            return colorScaleS(node[0]);\r\n          }\r\n        })\r\n        .style('stroke-width', 2)\r\n        .attr('rx', 4);\r\n      svg\r\n        .selectAll('.tooltip')\r\n        .data(() => {\r\n          if (choice === 'sentiment') {\r\n            return [[value['sentiment'], value['word']]];\r\n          } else return [[value['amount'], value['word']]];\r\n        })\r\n        .join((enter) => enter.append('text'))\r\n        .attr('class', 'tooltip')\r\n        .text((node) => {\r\n          if (choice === 'sentiment') {\r\n            return `sentiment: ${node[0]}, word: \"${node[1]}\"`;\r\n          } else return `${node[0]} times used: \"${node[1]}\"`;\r\n        })\r\n        .attr('x', (node) => {\r\n          let x = dimensions.width / 2;\r\n          for (let element of cleanEntries) {\r\n            if (element['word'] === node[1]) {\r\n              if (choice !== 'sentiment') {\r\n                if (dimensions.width <= 700) {\r\n                  x = dimensions.width / 2;\r\n                } else x = element['x'] + node[1].length * 4 + 200;\r\n              } else x = dimensions.width / 2;\r\n            }\r\n          }\r\n          return x;\r\n        })\r\n        .attr('text-anchor', 'middle')\r\n        .attr('y', (node) => {\r\n          for (let element of cleanEntries) {\r\n            if (choice !== 'sentiment') {\r\n              if (element['word'] === node[1]) {\r\n                return element['y'] + 25;\r\n              }\r\n            } else return dimensions.height / 2 + 25;\r\n          }\r\n        })\r\n        .attr('opacity', 1)\r\n        .attr('fill', 'black');\r\n    };\r\n    // Colors for Bubbles\r\n    const colorScale = scaleOrdinal()\r\n      .domain(new Set(scoreValues))\r\n      .range([\r\n        '#00e8e8',\r\n        '#F2CB05',\r\n        '#F28705',\r\n        '#D92818',\r\n        '#D94141',\r\n        '#0ba3ff',\r\n        '#6aafda',\r\n      ]);\r\n\r\n    const colorScaleS = scaleLinear()\r\n      .domain([-2, 2])\r\n      .range(['rgb(217, 29, 0)', 'rgb(66, 230, 0)']);\r\n\r\n    // Determines the scale based on screen size\r\n    let scaleBubbles = 1.3;\r\n    if (dimensions.width <= 700) scaleBubbles = 0.8;\r\n\r\n    // Scale for bubbles using scale var\r\n    const scaleL = d3\r\n      .scaleSqrt()\r\n      .domain([minValue, maxValue])\r\n      .range([25 * scaleBubbles, 60 * scaleBubbles]);\r\n\r\n    let scaleBubblesS = 2;\r\n\r\n    const scaleLS = d3\r\n      .scaleSqrt()\r\n      .domain([0, 5])\r\n      .range([0 * scaleBubblesS, 25 * scaleBubblesS]);\r\n    svg.style('width', '100%').style('height', '100%');\r\n\r\n    svg.attr('viewbox', `0 0 ${dimensions.width} ${dimensions.height}`);\r\n\r\n    const xCenter = [\r\n      dimensions.width / 4,\r\n      dimensions.width - dimensions.width / 4,\r\n    ];\r\n\r\n    const simulationBubbles = () => {\r\n      forceSimulation(data)\r\n        .force('charge', forceManyBody().strength(20))\r\n        .force(\r\n          'x',\r\n          choice === 'sentiment'\r\n            ? d3.forceX().x((d) => {\r\n                if (choice === 'sentiment') {\r\n                  return d['category'] === 0 ? xCenter[0] : xCenter[1];\r\n                }\r\n              })\r\n            : null\r\n        )\r\n        .force(\r\n          'center',\r\n          forceCenter(dimensions.width / 2, dimensions.height / 2)\r\n        )\r\n        .force(\r\n          'collide',\r\n          forceCollide().radius((node) => {\r\n            if (choice === 'sentiment') {\r\n              return scaleLS(Math.abs(Number(node['sentiment'])));\r\n            } else return scaleL(node['amount']);\r\n          })\r\n        )\r\n        .on('tick', () => {\r\n          svg\r\n            .selectAll('.node')\r\n            .data(data)\r\n            .join('circle')\r\n            .attr('class', 'node')\r\n            .attr('r', (node) => {\r\n              if (choice === 'sentiment') {\r\n                return scaleLS(Math.abs(Number(node['sentiment'])));\r\n              } else return scaleL(node['amount']);\r\n            })\r\n            .style('fill', (node) => {\r\n              if (choice === 'sentiment') {\r\n                return colorScaleS(node['sentiment']);\r\n              } else return colorScale(node['amount']);\r\n            })\r\n            .attr('cx', (node) => node.x)\r\n            .attr('cy', (node) => node.y)\r\n            .on('mouseenter', (value) => {\r\n              mouseEnter(value);\r\n            })\r\n            .on('mouseleave', () => {\r\n              svg.selectAll('.tooltip').remove();\r\n              svg.selectAll('.rec').remove();\r\n            });\r\n          svg\r\n            .selectAll('.label')\r\n            .data(data)\r\n            .join('text')\r\n            .attr('class', 'label')\r\n            .attr('text-anchor', 'middle')\r\n            .attr('font-size', (node) => {\r\n              if (choice === 'sentiment') {\r\n                return scaleLS(Math.abs(node['sentiment'])) / 3;\r\n              } else return scaleL(node['amount']) / 3;\r\n            })\r\n            .attr('font-family', 'Open Sans')\r\n            .style('fill', 'black')\r\n            .attr('font-weight', '600')\r\n            .text((node) => {\r\n              return node['word'];\r\n            })\r\n            .attr('x', (node) => node.x)\r\n            .attr('y', (node) => node.y)\r\n            .on('mouseenter', (value) => {\r\n              mouseEnter(value);\r\n            });\r\n        });\r\n    };\r\n\r\n    simulationBubbles();\r\n  }, [\r\n    dimensions,\r\n    cleanEntries,\r\n    data,\r\n    maxValue,\r\n    minValue,\r\n    scoreValues,\r\n    dataChoice,\r\n    choice,\r\n    bubbles2Count,\r\n  ]);\r\n\r\n  const handleChange = (e) => {\r\n    e.preventDefault();\r\n    updateChoice(e.target.value);\r\n\r\n    dispatch(setChoice(e.target.value));\r\n\r\n    const id = e.target.id;\r\n    const el = document.getElementById(id);\r\n    el.classList.add('bubblechart__difficulty-select--selected');\r\n\r\n    if (id === 'compare-sentiment') {\r\n      document\r\n        .getElementById('keywords')\r\n        .classList.remove('bubblechart__difficulty-select--selected');\r\n    } else if (id === 'keywords') {\r\n      document\r\n        .getElementById('compare-sentiment')\r\n        .classList.remove('bubblechart__difficulty-select--selected');\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div ref={wrapperRef} className=\"bubblechart\">\r\n      <div className=\"bubblechart__select-menue\">\r\n        <button\r\n          className=\"bubblechart__difficulty-select bubblechart__difficulty-select--selected\"\r\n          value=\"keywords\"\r\n          id=\"keywords\"\r\n          onClick={(e) => handleChange(e)}\r\n        >\r\n          Keywords\r\n        </button>\r\n        <button\r\n          className=\"bubblechart__difficulty-select\"\r\n          value=\"sentiment\"\r\n          id=\"compare-sentiment\"\r\n          onClick={(e) => handleChange(e)}\r\n        >\r\n          Compare Sentiments\r\n        </button>\r\n      </div>\r\n      <svg ref={svgRef}></svg>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Bubblechart;\r\n","import { SET_CHOICE } from './constants';\r\n\r\nexport const setChoice = (choice) => ({\r\n  type: SET_CHOICE,\r\n  choice,\r\n});\r\n","import React from 'react';\r\nimport { scaleLinear } from 'd3';\r\nimport { useSelector } from 'react-redux';\r\nimport { v4 as uuidv4 } from 'uuid';\r\n\r\nfunction HighestLowestAverage({\r\n  lowestComment,\r\n  highestComment,\r\n  sentiment,\r\n  sentimentCount,\r\n}) {\r\n  const highestCommentLikes = useSelector(\r\n    (state) => state.highestAndLowestCommentCount[0]\r\n  );\r\n\r\n  const lowestCommentLikes = useSelector(\r\n    (state) => state.highestAndLowestCommentCount[1]\r\n  );\r\n\r\n  const colorScale = scaleLinear()\r\n    .domain([-2, 2])\r\n    .range(['rgb(238, 0, 0)', 'rgb(66, 230, 0)']);\r\n\r\n  const styleHighest = {\r\n    color: colorScale(highestComment[0]),\r\n  };\r\n\r\n  const styleLowest = {\r\n    color: colorScale(lowestComment[0]),\r\n  };\r\n\r\n  const average = {\r\n    color: colorScale(sentiment),\r\n  };\r\n\r\n  const generateSentimentField = () => {\r\n    const headings = [\r\n      'Highest Sentiment',\r\n      'Lowest Sentiment',\r\n      'Average Sentiment',\r\n    ];\r\n    let output = [];\r\n    for (let heading of headings) {\r\n      output.push(\r\n        <div className=\"card\" key={uuidv4()}>\r\n          <span className=\"card__heading\">\r\n            <h2 className=\"card__title\">{heading}</h2>\r\n            <div\r\n              className=\"card__sentiment\"\r\n              style={\r\n                heading === 'Lowest Sentiment'\r\n                  ? styleLowest\r\n                  : heading === 'Highest Sentiment'\r\n                  ? styleHighest\r\n                  : average\r\n              }\r\n            >\r\n              {heading === 'Highest Sentiment'\r\n                ? highestComment &&\r\n                  (highestComment[0] > 0 ? '+' : '') +\r\n                    highestComment[0].toString().slice(0, 5)\r\n                : heading === 'Lowest Sentiment'\r\n                ? lowestComment &&\r\n                  (lowestComment[0] > 0 ? '+' : '') +\r\n                    lowestComment[0].toString().slice(0, 5)\r\n                : (sentiment > 0 ? '+' : '') + sentiment.toString().slice(0, 4)}\r\n            </div>\r\n          </span>\r\n          {heading === 'Highest Sentiment' || heading === 'Lowest Sentiment' ? (\r\n            <div className=\"card__comment\">\r\n              {heading === 'Highest Sentiment'\r\n                ? `\"${highestComment[1]}\"`\r\n                : heading === 'Lowest Sentiment'\r\n                ? `\"${lowestComment[1]}\"`\r\n                : null}\r\n            </div>\r\n          ) : null}\r\n          {heading === 'Average Sentiment' ? (\r\n            <div className=\"card__average\">\r\n              <h6 className=\"card__average-sentiment\">\r\n                Negative Sentiments: {sentimentCount[0]}\r\n              </h6>\r\n              <h6 className=\"card__average-sentiment\">\r\n                Neutral Sentiments: {sentimentCount[1]}\r\n              </h6>\r\n              <h6 className=\"card__average-sentiment\">\r\n                Positive Sentiments: {sentimentCount[2]}\r\n              </h6>\r\n            </div>\r\n          ) : null}\r\n          {heading === 'Lowest Sentiment' ? (\r\n            <div className=\"card__comment-likes\">\r\n              Likes:\r\n              {lowestCommentLikes}\r\n            </div>\r\n          ) : heading === 'Highest Sentiment' ? (\r\n            <div className=\"card__comment-likes\">\r\n              Likes:\r\n              {highestCommentLikes}\r\n            </div>\r\n          ) : (\r\n            <div className=\"card__comment-likes\">\r\n              Comments: {sentimentCount.reduce((a, b) => a + b)}\r\n            </div>\r\n          )}\r\n        </div>\r\n      );\r\n    }\r\n    return output;\r\n  };\r\n\r\n  return <div className=\"comments\">{generateSentimentField()}</div>;\r\n}\r\n\r\nexport default HighestLowestAverage;\r\n","/**\r\n * Prefilter the comments into positive and negative comments\r\n * Makes the sorting easier later\r\n */\r\nexport const filterComments = (comments) => {\r\n  let positive = [];\r\n  let negative = [];\r\n  for (let comment of comments) {\r\n    if (comment[3] > 0) {\r\n      positive.push(comment);\r\n    } else if (comment[3] < 0) {\r\n      negative.push(comment);\r\n    }\r\n  }\r\n\r\n  positive = sortCommentsBySentiment(positive, '+');\r\n  negative = sortCommentsBySentiment(negative, '-');\r\n\r\n  return [positive, negative];\r\n};\r\n\r\n// Sort the comments by sentiment value\r\nconst sortCommentsBySentiment = (comments, indicator) => {\r\n  let sorted = [];\r\n  let values = [];\r\n\r\n  // Give the comments ID's for later identification\r\n  let index = 0;\r\n  for (let comment of comments) {\r\n    comment.push(index);\r\n    index++;\r\n  }\r\n\r\n  // Get all the sentiment-values\r\n  for (let comment of comments) {\r\n    values.push(comment[3]);\r\n  }\r\n\r\n  // Sort all the sentiment values\r\n  if (indicator === '+') {\r\n    values = values.sort((a, b) => a - b).reverse();\r\n  } else {\r\n    values = values.sort((a, b) => a - b);\r\n  }\r\n\r\n  /**\r\n   * Go through the values and find their belonging comment - if the\r\n   * index is already used, continue searching for the belonging value\r\n   */\r\n  const usedIndexes = [];\r\n  for (let value of values) {\r\n    for (let comment of comments) {\r\n      if (comment[3] === value && usedIndexes.indexOf(comment[5]) === -1) {\r\n        sorted.push(comment);\r\n        usedIndexes.push(comment[5]);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return sorted;\r\n};\r\n","import React, { useState, useEffect } from 'react';\r\nimport { useSelector } from 'react-redux';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport InfiniteScroll from 'react-infinite-scroller';\r\n\r\n//Helper\r\nimport { filterComments } from './helper/filterComments_helper';\r\n\r\nfunction InfiniteScrollWindow() {\r\n  let comments = useSelector((state) => state.comments);\r\n  let [commentsFiltered, setCommentsFiltered] = useState();\r\n  let [positiveComments, setPositiveComments] = useState();\r\n  let [negativeComments, setNegativeComments] = useState();\r\n  const [hasmoreItems, setHasmoreItems] = useState(true);\r\n\r\n  /**\r\n   * Filters the comments when comments change\r\n   */\r\n  useEffect(() => {\r\n    setCommentsFiltered(filterComments(comments));\r\n  }, [comments]);\r\n\r\n  /**\r\n   * When filtered comments change update the positive and negative comments\r\n   */\r\n  useEffect(() => {\r\n    commentsFiltered && setPositiveComments(commentsFiltered[0].slice(0, 10));\r\n    commentsFiltered && setNegativeComments(commentsFiltered[1].slice(0, 10));\r\n  }, [commentsFiltered]);\r\n\r\n  const loadMorePositive = () => {\r\n    let count = positiveComments.length + 5;\r\n    if (count >= commentsFiltered[0].length) {\r\n      setHasmoreItems(false);\r\n      return;\r\n    }\r\n    setPositiveComments(commentsFiltered[0].slice(0, count));\r\n  };\r\n\r\n  const loadMoreNegative = () => {\r\n    let count = negativeComments.length + 5;\r\n    if (count >= commentsFiltered[1].length) {\r\n      setHasmoreItems(false);\r\n      return;\r\n    }\r\n    setNegativeComments(commentsFiltered[1].slice(0, count));\r\n  };\r\n\r\n  if (!positiveComments || !negativeComments) return null;\r\n\r\n  return (\r\n    <div className=\"infinite-wrapper\">\r\n      <div className=\"infinite-scroll\">\r\n        <h2 className=\"infinite-scroll__heading\">\r\n          Selected positive sentiments:\r\n        </h2>\r\n        <InfiniteScroll\r\n          className=\"infinite-scroll__wrapper\"\r\n          pageStart={0}\r\n          loadMore={loadMorePositive}\r\n          hasMore={hasmoreItems}\r\n          loader={\r\n            <div className=\"loader\" key={0}>\r\n              Loading ...\r\n            </div>\r\n          }\r\n          useWindow={false}\r\n          getScrollParent={() =>\r\n            document.getElementsByClassName('infinite-scroll')[0]\r\n          }\r\n        >\r\n          {positiveComments &&\r\n            positiveComments.map((comment) => {\r\n              return (\r\n                <div className=\"comment\" key={uuidv4()}>\r\n                  <div className=\"comment__text\">{`\"${comment[0]}\"`}</div>\r\n                  <div className=\"comment__sentiment\">\r\n                    {comment[3].toString().slice(0, 6)}\r\n                  </div>\r\n                </div>\r\n              );\r\n            })}\r\n        </InfiniteScroll>\r\n      </div>\r\n      <div className=\"infinite-scroll\">\r\n        <h2 className=\"infinite-scroll__heading\">\r\n          Selected negative sentiments:\r\n        </h2>\r\n        <InfiniteScroll\r\n          className=\"infinite-scroll__wrapper\"\r\n          pageStart={0}\r\n          loadMore={loadMoreNegative}\r\n          hasMore={hasmoreItems}\r\n          loader={\r\n            <div className=\"loader\" key={0}>\r\n              Loading ...\r\n            </div>\r\n          }\r\n          useWindow={false}\r\n          getScrollParent={() =>\r\n            document.getElementsByClassName('infinite-scroll')[1]\r\n          }\r\n        >\r\n          {negativeComments &&\r\n            negativeComments.map((comment) => {\r\n              return (\r\n                <div className=\"comment\" key={uuidv4()}>\r\n                  <div className=\"comment__text\">{`\"${comment[0]}\"`}</div>\r\n                  <div className=\"comment__sentiment\">\r\n                    {comment[3].toString().slice(0, 6)}\r\n                  </div>\r\n                </div>\r\n              );\r\n            })}\r\n        </InfiniteScroll>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default InfiniteScrollWindow;\r\n","import React from 'react';\r\nimport { useSelector } from 'react-redux';\r\nimport Bubblechart from './Bubblechart';\r\nimport HighestLowestAverage from './HighestLowestAverage';\r\nimport InfiniteScrollWindow from './InfiniteScrollWindow';\r\n\r\nfunction Display() {\r\n  const sentiment = useSelector((state) => state.sentiment.sentiment);\r\n  const sentimentCount = useSelector((state) => state.sentiment.sentimentCount);\r\n  const highestComment = useSelector((state) => state.sentiment.highestComment);\r\n  const lowestComment = useSelector((state) => state.sentiment.lowestComment);\r\n  const videoTitle = useSelector((state) => state.videoTitle);\r\n  const keyCounts = useSelector((state) => state.keyCounts);\r\n  const singleWordSentiments = useSelector(\r\n    (state) => state.singleWordSentiments\r\n  );\r\n\r\n  if (!sentiment) return null;\r\n  return (\r\n    <div className=\"display\">\r\n      <h2 className=\"display__title-name\">{videoTitle}</h2>\r\n      <HighestLowestAverage\r\n        sentimentCount={sentimentCount}\r\n        lowestComment={lowestComment}\r\n        highestComment={highestComment}\r\n        sentiment={sentiment}\r\n      />\r\n      <InfiniteScrollWindow />\r\n      <Bubblechart data={keyCounts} dataSingleWords={singleWordSentiments} />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Display;\r\n","import React from 'react';\nimport Search from './components/Search';\nimport Display from './components/Display';\n\nfunction App() {\n  return (\n    <div className=\"app\">\n      <h1 className=\"app__page-title\">Consensus</h1>\n      <p className=\"app__subheading\">AFINN Youtube Sentiment Analysis</p>\n      <Search />\n      <Display />\n    </div>\n  );\n}\n\nexport default App;\n","import {\r\n  SET_SENTIMENT,\r\n  SET_SENTIMENT_COUNT,\r\n  SET_HIGHEST_COMMENT,\r\n  SET_LOWEST_COMMENT,\r\n  SET_COMMENT_COUNT,\r\n} from '../actions/constants';\r\n\r\nconst initialState = {\r\n  sentiment: 0,\r\n  sentimentCount: [null, null],\r\n  highestComment: '',\r\n  lowestComment: '',\r\n  commentCount: 0,\r\n};\r\n\r\nexport const sentiment = (state = initialState, action) => {\r\n  switch (action.type) {\r\n    case SET_SENTIMENT:\r\n      return {\r\n        ...state,\r\n        sentiment: action.sentiment,\r\n      };\r\n    case SET_SENTIMENT_COUNT:\r\n      return {\r\n        ...state,\r\n        sentimentCount: action.sentimentCount,\r\n      };\r\n    case SET_HIGHEST_COMMENT:\r\n      return {\r\n        ...state,\r\n        highestComment: action.highestComment,\r\n      };\r\n    case SET_LOWEST_COMMENT:\r\n      return {\r\n        ...state,\r\n        lowestComment: action.lowestComment,\r\n      };\r\n    case SET_COMMENT_COUNT:\r\n      return {\r\n        ...state,\r\n        commentCount: action.commentCount,\r\n      };\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n","import {\r\n  SET_HIGHEST_SENTIMENT_SINGLE_WORDS,\r\n  SET_LOWEST_SENTIMENT_SINGLE_WORDS,\r\n} from '../actions/constants';\r\n\r\nconst initialState = {\r\n  highestSingleWords: [],\r\n  lowestSingleWords: [],\r\n};\r\n\r\nexport const singleWordSentiments = (state = initialState, action) => {\r\n  switch (action.type) {\r\n    case SET_HIGHEST_SENTIMENT_SINGLE_WORDS:\r\n      return {\r\n        ...state,\r\n        highestSingleWords: action.highestSingleWords,\r\n      };\r\n    case SET_LOWEST_SENTIMENT_SINGLE_WORDS:\r\n      return {\r\n        ...state,\r\n        lowestSingleWords: action.lowestSingleWords,\r\n      };\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n","import { combineReducers } from 'redux';\r\nimport { videoTitle } from './videoTitle';\r\nimport { sentiment } from './sentiment';\r\nimport { keyCounts } from './keyCounts';\r\nimport { comments } from './comments';\r\nimport { highestAndLowestCommentCount } from './highestAndLowestCommentCount';\r\nimport { singleWordSentiments } from './singleWordSentiments';\r\nimport { choice } from './choice';\r\nimport { noCommentsModal } from './noCommentsModal';\r\n\r\nexport default combineReducers({\r\n  videoTitle,\r\n  sentiment,\r\n  keyCounts,\r\n  comments,\r\n  highestAndLowestCommentCount,\r\n  singleWordSentiments,\r\n  choice,\r\n  noCommentsModal,\r\n});\r\n","import { SET_VIDEO_TITLE } from '../actions/constants';\r\n\r\nexport const videoTitle = (state = '', action) => {\r\n  switch (action.type) {\r\n    case SET_VIDEO_TITLE:\r\n      return action.videoTitle;\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n","import { SET_KEYCOUNTS } from '../actions/constants';\r\n\r\nexport const keyCounts = (state = {}, action) => {\r\n  switch (action.type) {\r\n    case SET_KEYCOUNTS:\r\n      return action.keyCounts;\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n","import { SET_COMMENTS } from '../actions/constants';\r\n\r\nexport const comments = (state = {}, action) => {\r\n  switch (action.type) {\r\n    case SET_COMMENTS:\r\n      return action.comments;\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n","import { SET_HIGHEST_AND_LOWEST_COMMENT_COUNT } from '../actions/constants';\r\n\r\nexport const highestAndLowestCommentCount = (state = {}, action) => {\r\n  switch (action.type) {\r\n    case SET_HIGHEST_AND_LOWEST_COMMENT_COUNT:\r\n      return action.highLowCommentCount;\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n","import { SET_CHOICE } from '../actions/constants';\r\n\r\nexport const choice = (state = 'keywords', action) => {\r\n  switch (action.type) {\r\n    case SET_CHOICE:\r\n      return action.choice;\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n","import { TOGGLE_NO_COMMENTS_MODAL } from '../actions/constants';\r\n\r\nexport const noCommentsModal = (state = false, action) => {\r\n  switch (action.type) {\r\n    case TOGGLE_NO_COMMENTS_MODAL:\r\n      return !state;\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n","import { createStore, applyMiddleware } from 'redux';\r\nimport { composeWithDevTools } from 'redux-devtools-extension';\r\nimport thunk from 'redux-thunk';\r\nimport rootReducer from '../reducers';\r\n\r\nconst initialState = {};\r\n\r\nconst middleware = [thunk];\r\n\r\nconst store = createStore(\r\n  rootReducer,\r\n  initialState,\r\n  composeWithDevTools(applyMiddleware(...middleware))\r\n);\r\n\r\nexport default store;\r\n","import 'react-app-polyfill/ie9';\nimport 'react-app-polyfill/stable';\nimport 'core-js/stable';\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport store from './store';\nimport { Provider } from 'react-redux';\nimport './styles/main.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}